# flex 字詞分析器

陳維志(weijyh.chen@gmail.com)

## 前言

本書是針對編譯器製作工具 flex 的說明，要能輕鬆看懂本書要有一定的能力，請先看過我寫的另一本書「8086 組合語言」，如此將事半功倍。

寫編譯器是程式設計師提升功力的必經之路，唯有精熟一門高階語言及組合語言，才能寫出編譯器，我的書都是和 C 語言及組合語言相關的技術，換言之，我都是教導如何用 C 語言及相關工具寫出編譯器的技術，其它高階語言則不是此書的考量。

直接不用工具也可以寫編譯器，尤其是字詞分析器，但本書是給你另一種選擇，即使用工具完成編譯器的一部份工作。

一個編譯器大致上由下圖中的四個部份組成，下方是相對應工具程式的名稱：

![](C:\Users\user\Documents\Images\2024-08-02-17-41-22-image.png)

每一個部份都有相關工具程式可以使用，字詞分析工具是 flex，語法分析工具是 bison，優化及後端工具是 llvm。使用這些工具將使編譯器的寫作更輕鬆，但卻不是一定的事情，因為工具的學習也是一件不容易的事情，而且使用工具會讓人對工具的內部運作原理無法清楚明瞭。

對學習和研究很有興趣的人來說，使用了一個工具程式，當然可以再去研究工具程式的原理，這些工具程式都是開放原始碼的程式，相關的書籍也都會說明它們的用法及原理。

本書就是對 flex 的使用及基本原理加以講解的書籍，學過後應該可以寫出編譯器的字詞分析器，但若要想寫一個類似 flex 工具的程式，還要再懂有限自動機的知識才可以做到，不懂也可以，只是較難而已。

> 傳統的字詞分析工具叫做 lex ，它是在 UNIX 作業系統中見的工具，flex 是 Gnu 重寫的字詞分析工具，大致用法和 lex 一樣，若對 lex 有興趣，可以去找 BSD Unix 的原始碼，其中應該可以找到 lex 原始程式，下載編譯後可以依本書範例試看看。
> 
> 講解 lex 的書籍也有，網路上找找，應該還可以找來參考。

## 字詞分析程式的意義

字詞分析程式的輸入是一個文字檔，輸出是文字檔中被找出的字詞。如下圖所示：

![](C:\Users\user\Documents\Images\2024-08-05-06-44-57-image.png)

通常字詞分析程式是在編譯器中的第一段中使用，它可將輸入的程式語言，按照字詞先做切割分類，但字詞分析程式不限定用於編譯器，也可以用來做語言翻譯。例如上圖中，我們輸入的一段英文字(檔案)到字詞分析程式，它會按照將英文單字結合為字詞，而後查詢每個字詞的分類，而後輸出字詞分類的結構。

字詞分析程式並不會去做語法的分析，例如上圖「主詞 + be 動詞 + 冠詞 + 名詞」符合或不符合語法，是和字詞分析程式無關的事情，上面 students 是複數就不太合理，但要記住這個與字詞分析程式無關。語法合不合理是語法分析程式的事情，像前面的例子，因為不符合基本的英文語法，故語法分析理應輕易找出它是錯的語法。符合語法也不一定就是對的句子，這又和語法分析程式無關了，例如 「We are the world.」 這句話，應該是符合語法的，但是若直接看它的意義又不甚合理，「我們是世界。」我們是人，雖然是世界的一部份，但不會等於世界，所以這句話符合語法，但不甚正確。不甚正確的原因是因為正不正確已不是邏輯上黑白分明的事情，端看語法分析後面要如何處理語句的意義，這是語義分析程式的作用，不同的語義分析程式，對這句話可能有不同解釋。

有點離題了，回來說我們的字詞分析程式，字詞分析程式的輸出，我們稱做字符標記(token)，上圖中的「主詞」就是一個 token，在程式中我們會用一個數值來代表它，例如 1 是主詞，2 是動詞，...，token 後面的 "I" 是隨附該 token 的原始字詞，這個結構會傳給後端的語法分析程式，語法分析程式會不斷地從字詞分析程式拿取 token ，例如它收到了 token = 2，它就知道它是收到了一個動詞。

以上說明了字詞分析程式的作用，搭配後面的每個例子，循序漸進，你就可以充分了解字詞分析程式的作用了。 flex 是一個能產生字詞分析程式的工具，它本身不是字詞分析程式，硬要說，它也像是一個翻譯器，它把你所寫的字詞辨認規則，翻譯成一個 C 語言程式，這個 C 語言程式才是字詞分析程式。

字詞分析程式也可以不用 flex 工具產生，只要你會寫程式，也可以不用工具，直接寫程式去做到字詞分析的工作，例如上圖中的英文翻譯程式中的字詞分析，用 C 語言直接寫也不是問題，只是好寫不好寫及寫得好不好的問題而已。

## 下載及安裝 flex

flex 的程式在不同作業系統中都可以下載安裝，或者也可以到 Gnu 網站下載原始碼回來編譯，本書的示範都是在 DOS 作業系統中使用 DJGPP GCC 編譯器完成，只要安裝了 DJGPP 編譯系統就可以有 flex 了。

詳細安裝 DJGPP 及模擬環境的過程，請參考我的另一本書「8086 組合語言」，該書中有說明如何安裝 DOSBox 模擬器，以及在其中安裝 DJGPP 的整個過程，故在此書不再重覆。

#### 測試:第一個 flex 程式

請進入 DOSBox 模擬器中，用下列指令進入 c:\tmp 目錄，如果沒有該目錄，請自行用 DOS 命令 md c:\tmp 建立該目錄。

    cd c:\tmp

而後在該目錄中建立如下內容的 EX1.L 程式，在此故意用大寫為了讓讀者看清 L ，後面將用小寫指出檔名，事實上，檔名都可以由你自訂，沒有一定要是 ex1.l ，只要你自己知道後續操作是針對 ex1.l 就可以了。

    %option outfile="ex1.c"
    %option noyywrap
    
    %%
    q       { exit(0); }
    .|\n    ECHO;
    %%

建立好 ex1.l 後，用以下命令將其轉成 C 程式碼。

    flex ex1.l

如此將會產生一個 ex1.c 的檔案，不用特別去看這個檔案的內容，它是工具產生的 C 語言程式，很冗長，故在此也不列出。有了這個 ex1.c 檔，就可以用 gcc 編譯它了，如下命令：

    gcc -o ex1.exe -lfl ex1.c

編譯器選項 -lfl 是要 gcc 在連結時要包含 libfl.a 的檔案，因為 ex1.l (ex1.c) 中沒有 main 函式，所以要使用 flex 函式庫中提供的 main 函式，事實上，我們也可以寫自己的 main 函式，將 ex1.l 修改如下：

    %option outfile="ex1.c"
    %option noyywrap
    
    %%
    quit    { exit(0); }
    .|\n    ECHO;
    %%
    
    main() {
        yylex();
    }

存檔後，用下列命令產生 ex1.exe 執行檔，即第一個簡單的詞法分析程式。

    gcc -o ex1.exe ex1.c

執行 ex1.exe ，不論輸入何字詞，然後按下 enter 鍵，都只會再被印出(ECHO)一次，除非按下的是 quit 小寫字元，才會結束程式。

## flex 程式結構

flex 字詞分析程式的結構由三個主要部份構成，每一個部份由 %% 加以分隔，若沒有第三部份，則第二個 %% 分隔符號可以省略。

    %{
     C 語言程式定義段
    %}
    flex 定義段 
    
    %% 
    
    flex 規則段 
    
    %% 
    
    自訂 C 語言函式段

flex 程式的第一段是定義段，主要由二部份構成，

1. C 語言程式定義段：通常 C 語言中的 #define 集中於此段，也可在此段中定義全域變數或資料結構。此段程式會由 flex 工具程式直接放到輸出的 C 語言程式中。

2. flex 定義段

以上二分段都可有可無，端看使用者的決定。如果沒有定義段的內容，可以空白，後面一定要接著 %% 表示進入了第二段。

第二段是規則端，一般而言不會空白，如果空白就好像交白卷一樣，這個程式什麼都沒做，豪無意義。

規則段由一行一行的字詞匹配規則構成，每行的前面是匹配樣式，後面用分隔符分開成欲執行的程式。例如

    am    {token=2;}

上面這行匹配規則會將輸入文字中的 am 找出來，找到後會執行後面的 C 語言程式，將 token 設為 2， token 是 C 語言中的一個整體性變數。 C 語言程式用大括號包住，可以不止一行，通常不會寫太長程式在這裡面，以免影響整個匹配規則的閱讀。

有關完整的匹配規則說明則在後面介紹。第二段後又要接著 %% 符號，但若沒有第三段可以省略，我建議所有可以省略的東西，都不要省略，留著會讓程式結構清楚，易於閱讀，而且是自己寫程式的一種樣式習慣，統一的寫程式習慣讓自己看的更清楚，不是自己寫的程式，一眼就可以看出來。這樣的建議，要不要採納就看個人的喜好了。

第三段是自訂 C 語言函式段，在第二段中一般會插入短的 C 語言程式，若程式太長，要考慮改成呼叫函式，而被呼叫的函式就可以放在這第三段，例如：

    %%
    am      { process_token(2, "am");}
    %%
    void process_token(int token, char* token_string) {
        ...
    }
    int main() {
        yylex();
    }

上面第三段中加入了一個 process_token 的自訂函式，內容要做什麼則是由程式師自行決定。第三段中通常也會放入 main 函式，自訂的 main 函式可以更靈活的使用 yylex() 字詞分析程式，最簡單的用法就是如上所示，直接呼叫 yylex() 函式，這也是 flex 函式庫中 main 的定義。

#### 範例

以下是範例程式

    %option outfile="ex2.c"
    %option noyywrap
    
    %{
    #define APP     1
    #define APPLE   2
    %}
    
    %%
    quit    {exit(0);}
    app     {printf("yytext=%s\n",yytext);return APP;}
    apple   {printf("yytext=%s\n",yytext);return APPLE;}
    %%
    
    int main() {
            while (1) {
                    int token=yylex();
                    printf("token=%d\n",token);
            }
    }

執行結果如下圖：

![](C:\Users\user\Documents\Images\2024-08-02-17-21-24-image.png)
