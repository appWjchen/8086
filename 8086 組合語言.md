# 8086 組合語言

陳維志(weijyh.chen@gmail.com)

## 前言及學習條件

> 記事：
> 
> 2024/07/19 Microsoft Windows 大當機，造成多家航空公司系統無法運作，所有航班不是取消就是延誤，有一家歐洲的航空公司因為使用古老的 Windows 3.1 而不受影響，這件事說明了什麼? Windows 3.1 比較安全?! 當然不是，只是再次證明沒有任何系統是永遠安全的。只有自己能完全掌握的系統，才能盡快復原，在學習程式設計的路途上，唯有 open source 才能讓你感到安全。 

#### 前言

對於想要研究編譯器(例如 GCC)及作業系統(例如 Linux)的人來說，不會組合語言是不可能的事情。

現今學習組合語言，大致可選的有二種，一是 x86 系統，包括 16 位元、32 位元及 64 位元，二是 ARM 系統，直接學 64 位元即可。

當初 Linux 是從 x86 開始，其它 CPU 的移植，在當時不夠成熟，多數 Linux 發行版本，如 Ubuntu、Debian、RedHat...都以 x86 電腦為主，而後才逐步出現跨平台的程式，所以先學 x86 組合語言，跟隨 Linux 發展的腳步來學習，一步步走到 64 位元組合言言，這一路都有 Linux 及眾多套件的原始程式相伴，你絕對不會寂莫，不會為了找不到該死的資料而洩氣，或者找不到人聊天。等學完 x64 組合語言，立刻可以切換到 ARM 64 bits 組合語言(Raspberry pi 模擬器也很普及)的學習，也會順利很多。

> 建議：
> 
> 只寫你懂的指令及程式敍述，任何不能完全了解的指令不要寫出，直到你完全掌握為止。

#### 學習條件

本書讀者要先有電腦基本操作的能力，例如拷貝檔案、使用記事本、瀏覽網頁、下載檔案、解壓檔案。以上列出不限定只有這些，只要是上查得到的基本電腦知識，本書就儘可能減少說明的篇幅。  

電腦中使用的二進制、八進制及十六進制系統，也請讀者自行上網查詢資料，學會它們和十進制之間的轉換。

常見作業系統的命令列操作，例如 Linux shell 及 Windows 的命令提示字元，也請上網自學。本書也只會提及常用的命令及用法，不會涵蓋完整的使用。

## 第1章 系統安裝及設定

#### 系統選擇

想要學習古老的 8086 組合語言，一定有其原因，這不深究，在現今大都是 64 位元 (128 bits 電腦還不多見)的天下，安裝的開發系統不是沒法組譯 8086 組合語言，就是組譯出來也沒法現場執行，所以最好還是回到老系統下去玩，比較輕鬆。

老系統的選擇就不多了，你可以選 DOS、MINIX、BSD ...，最終我選了 DOS，不是我最會用 DOS，而是 MINIX 有人玩過了，其它的連要跑起來都吃力，只有 DOS 跑起來最容易，只要下載個模擬器就可以開始研究了。

接著，要考慮用哪種 DOS 模擬器，有 DOSBox、Bochs、QEMMU、Virtual Box、...，我是選用 DOSBox，你可以等到研究透徹了，再改用別的模擬器也可以，事實上，Virtual Box 應該才是最穩固(一直有更新)的選擇。

我會選擇用 DOSBox 是因為檔案操作簡單，它內部 DOS 檔案系統就是模擬器外部作業系統的一個目錄，須要什麼東西，從外部作業系統下載、解壓後，就可以直接 copy 到 DOS 檔案系統中，其它的模擬器要想辦法把檔案放進去內部 DOS 系統，並不是做不到，只是較麻煩一點而已，相反來說，要把你在 DOS 中寫的程式拿出來備份，也是 DOSBox 最簡單，copy 就容易。

另一個我會選擇 DOSBox 的原因是，它在 Android 平板上也有 Magic DOSBox 可以用，內外檔案系統是相連的，在其它地方下載的原始碼直接就在 DOS 中看得到，寫好的程式也直接可以在檔案總管(或檔案管理器)中看得到，後面會對此加以介紹。如此就可以隨時用手機或平板寫組合語言程式了。

DOSBox 不是沒有缺點，它內定是 DOS 5.0 ，而且沒法跑自己寫的作業系統，例如 Linux(雖然有 loadlin、ZipSlack 可以在DOS 下用，但不容易使用)，這對學習 8086 組合語言來說沒有任何問題，如果以後有出現 DOSBox 的做不到的事情時，再換別的模擬器就可以了。

#### 工具選擇

常有人會用各式各樣的工具去開發作業系統或編譯器，最終不了了之，他多半會認為是因為自己生不逢時，或者是選錯工具。這二件事是雞生蛋、蛋生雞的問題。

若能完全想明白，就會理解不論你在何時想要開始研究編譯器或作業系統(就算只是想學寫組合語言)，一定要先把上面講的這件事弄清楚。試想你在某個作業系統下(例如 DOS)，用了非開源的 C 編譯器及組譯器(例如  Microsoft C 和 MASM)的開發工具，你把作業系統寫好了，要怎樣證明你的作業系統將來可以繼續走下去?除非你寫的作業系統是 DOS 相容，否則你原本用來開發你的作業系統的工具，全都無法在你的作業系統中使用，這樣是無法繼續走下去的。想想當初 Linux 的景況吧，非開源的工具是沒法拿到你寫的作業系統下執行的，就算你寫的作業系統跑得起來，在那個系統中也沒有開發工具，該如何繼續呢?

遇到像上面這種情形，和你生不逢時一點關係也沒有，純粹一開始就自斷生路，當然若你只是想玩玩自製作業系統，證明自己有點能力，那就無可厚非了。

因此，要玩得長久，只有一開始就選擇使用開源(open source)工具，才能繼續玩下去。

接著考慮的是組合語言的開源組譯器那麼多，比如 NASM、JASM、FASM、Open Watcom ASM、...，該選擇哪個呢?多數人會選擇 NASM，因為它即開源又在多數作業系統下都可以安裝使用，我建議不要再犯上面的那種天真想法的錯誤了。Linux 中從來就只有 Gnu C/C++ 和 Gnu ASM，再想不透為何又要白走冤枉路，你只要想到 Linux 中眾多的程式都是用 Gnu 工具開發完成的，將來你拿著另一種組譯器去編譯這些程式，硬要說還真不是做不到，只是現成的 GCC 和 Gas 會簡單很多。雖然可能不一定，但畢竟眾多工具及應用都是用 GCC 寫成，至少在可攜性上，會好一點。

簡單說，要寫作業系統，就要寫出和 Linux 相容的作業系統，要寫編譯器，就要寫能在 Linux 中執行的編譯器。雖然這二件事都不簡單，但比起其它的選擇而言，我認為可能性更高。

對於8086 組合語言來說，使用 gas 組譯器來寫組合語言程式不是什麼大問題，但有點大材小用，我們把 gas 留著用來寫 80386 的組合語言程式，本書介紹一個叫 as86 的組譯器，用它來學習 8086 組合語言也非常容易。

as86 組譯器是什麼來頭，你可以上網查一下就知道，但畢竟事已久遠，不見得一定查得到，總之在此大略介紹一下，它是當初開發 Linux 作業系統時用到的組譯器之一，雖然那時只用它來組譯一個開機程式，但它的確是可以用來寫 8086 組合語言程式。會提這個是提醒大家，當初如果可以用 gas 組譯這個開機程式，為何要用 as86? 我們只能自己猜測了。

#### DOSBox 下載及安裝(Windows 10)

本書所有示範的內容是以 Windows 10 下安裝 DOSBox 為主要開發環境，但不限定一定要是這樣的搭配，其它作業系統也有 DOSBox 可以用，例如 Android 系統，在附錄中有介紹如何安裝及設定 Android 中的 DOSBox，這樣的搭配也一樣可以完成本書的所有內容。

你可以到下列網址去下載 DOSBox，理論上沒有病毒，因為不知道有多少人下載過了，Windows 的掃毒程式掃過 N 次了。你若不放心，大可不必冒險，可以試看看附錄中所講的 Android 版：

[DOSBox, an x86 emulator with DOS](https://www.dosbox.com/download.php?main=1)

如下圖所示，點擊 Windows 即可開始下載，過程中會切換到另一個網頁，不用理它(包括不要把它關掉)，幾秒後就會下載完畢，下載完畢後，就可以把所有網頁關掉了：

![](./Images/2024-07-21-07-12-57-image.png)

下載完成後，在你的「下載(Download)」資料夾中會有一個 DOSBox0.74-3-win32-installer.exe 檔案，如下圖，雙擊(double click)該檔案即可開始安裝 DOSBOX：

![](./Images/2024-07-21-07-34-47-image.png)

接著會跳出使用者帳戶控制視窗，請務必要按「是」，啟動安裝程式，

然後出現如下圖安裝視窗，請按「Next>」繼續：

<img src="./Images/2024-07-21-09-18-45-image.png" title="" alt="" width="450">

下一個視窗(如下圖)，請繼續按「Next>」：

<img src="./Images/2024-07-21-09-20-26-image.png" title="" alt="" width="449">

接著出現安裝路徑視窗，若有必要，請記下此安裝路徑，請按下「Install」開始安裝：

<img src="./Images/2024-07-21-09-21-54-image.png" title="" alt="" width="451">

最後，安裝完成後會如下圖，請按「Close」結束安裝。

<img src="./Images/2024-07-21-09-22-56-image.png" title="" alt="" width="453">

#### DOSBox 設定

安裝好 DOSBox 後，要先設定它才好使用，包括要模擬的 DOS 機器的記憶體大小，和啟動的程式等等。請從開始功能表找到 DOSBox 0.74-3 Options ，點擊它可以用記事本打開 DOSBox 設定檔案：

![](./Images/2024-07-21-10-35-05-image.png)

打開記事本後，找到 windowresolution= 的地方，把它改成你要的解析度大小，如果你的螢幕是 1920x1080，則設成 1600x800 就合適，如果是 4K 螢幕，請自行嘗試到自己滿意的解析度為止。下面一行 output=surface ，把它改成 output=ddraw ，使用 Windows 的 DirectDraw 函式來繪製 DOS 顯示結果。

接著往下找到 memsize 如下圖，把它改成 64，這樣是指你模擬出的的 DOS 機器有 64MB RAＭ，這對當時來說已是非常大的記憶體容量，雖然現在的電腦最少都有 4GB RAM，但不要改太大，先這樣設定就好，太大對模擬器及一些舊軟體可能會有不利影響，暫時也用不到那麼大的記憶體，反正可以再改。

![](./Images/2024-07-21-10-58-29-image.png)

改完記憶體後，其他就沒什麼好改的了，你可以上網查詢有哪些設定很重要，自己再去改，接著請先決定 DOSBox 啟動後要用哪個資料夾做為內部 DOS 的 C: 磁碟的目錄，請先用檔案總管在「文件」資料夾中建立一個 DOS 目錄，如果你的使用者名稱(Windows 10 登入時的使用者)不是英文的名稱，建議改成別的資料夾，例如 D:\DOS ，這個目錄你必須要有寫入的權限。

然後繼續在記事本中修改 DOSBox 設定檔，移到最後面，如下圖，加入下列指令：

    mount c: C:\Users\使用者名稱\Documents\DOS
    c:

![](./Images/2024-07-21-11-03-35-image.png)

再次提醒上圖中的 user 是我登入 Windows 的使用者名稱，因為是英文的，所以就可以直接拿來用，如果你是要用別的資料夾來當成 DOS 的 C: 磁碟，例如 D:\DOS (本機 Windows 的資料夾)，則最後二行要改為：

    mount c: d:\dos
    c:

把記事本中的內容存檔後，關掉記事本，就可以從「開始」功能表中找到 DOSBox 0.74-3 (noconsole)，點擊即可啟動 DOSBox 了(第一次)。如下圖所示：

![](./Images/2024-07-21-11-10-23-image.png)

要離開 DOSBox 可以在上面命令提示字元中，輸入 exit 指令，並按 enter 按鍵執行退出 DOSBox 的要求，也可以按下右上角 X (關閉視窗)按鈕，把 DOSBox 視窗關掉。

#### 安裝 DOS 4.0 程式

DOSBox 本身已經含有可啟動的 DOS 作業系統，你可以在上述視窗中打入 ver 命令(後面不再強調要按 enter 鍵)查看 DOSBox 本身模擬的 DOS 版本，如下圖：

![](./Images/2024-07-21-12-53-51-image.png)

可以看到它回報的是 DOS version 5.00，目前這個環境下，只能用一些內建的 DOS 指令，其它如 debug、edit 等程式都沒有，所以我們要去下載 DOS 5.0 的其它程式，才能使用完整的 DOS 5.0 全部命令。

因為我不確定目前使用 DOS 5.0 是否合法，所以不用 DOS 5.0，幾年前 Microsoft 就已公布了 DOS 4.0 的原始程式碼，只要不做商業用途，原始碼的使用沒有問題，如果要確定合法，請你下載 DOS 4.0 原始碼回來編譯使用。以下則示範從其它來源下載 MSDOS 4.01 版來使用，請自下列網址下載 DOS 4.01。

[WinWorld: Microsoft MS-DOS 4.01 (4-7-1989) (3.5-720k)](https://winworldpc.com/download/818a50a5-4563-11eb-b764-0200008a0da4)

在開始下個動作前，請先自行到 7-zip 網站(https://www.7-zip.org/ ) 下載 7-zip 解壓縮軟體，並安裝，由於過程相當簡單，所以就不在此多說。不過，如果真的安裝失敗，我想網路上教學文件很多，請自行解決這個問題，以下假設你已經安裝好 7-zip 解壓縮軟體。

請在下載的 Microsoft MS-DOS 4.01 (4-7-1989) (3.5-720k).7z 檔案上按右鍵，移到 7-zip 項目，而後選擇「解壓縮至 "Microsoft MS-DOS 4.01 (4-7-1989) (3.5-720k)"，如下圖所示：

![](./Images/2024-07-21-13-10-55-image.png)

接著打開解壓縮之後的資料夾，裡面有三個 .img 的檔案，這是 DOS 4 的三張軟碟映像檔，可以如上圖方式，用 7-zip 在三個檔案上按右鍵解壓出三個資料夾。

![](./Images/2024-07-21-13-12-39-image.png)

三個資料夾解壓之後，如下圖所示：

![](./Images/2024-07-21-13-14-18-image.png)

請先在 C:\Users\user\Documents\DOS (你的 DOS 外部系統可見之資料夾)資料夾中，建立一個 DOS4 的資料夾，而後將上圖中，三個資料夾中的檔案全部拷貝到 DOS4 資料夾中。

而後執行 DOSBox ，進入系統後，利用 cd dos4 命令可以切換到 dos4 資料夾，用 debug 命令欲執行 debug 程式，結果回報版本不對，然後用 ver set 4.01 將 DOSBox 回報程式的版本設為 4.01 版，再次使用 debug 就可以了。

![](./Images/2024-07-21-13-40-25-image.png)

你可以將下列命令加在 DOSBox 設定檔的最下面，這樣就不用每次進系統都要打這個命令：

    ver set 4.01

如果覺得 DOS 4.01 功能不是很足，你可以上網找你須要的 DOS 應用程式，自行複製到 DOS 目錄中。

接下來在本機 C:\Users\user\Documents\DOS 資料夾用記事本建立一個 autoexec.bat 檔案，打入下列內容，這是為了讓 DOSBox 啟動 DOS 後，自動執行一些工作，其中最重要的是設定 DOS 搜尋執行檔的路徑(path)：

    set path=c:\dos4

> 在本書中常會提及二個目錄，一個是本機路徑 C:\Users\user\Documents\DOS ，這個是在 Windows 10 中的檔案總管可以看到的目錄，另一個目錄是 DOSBox 中的 C:\ 目錄，這是在執行 DOSBox 時可以操作的 DOS 磁碟根目錄，事實上二個是同一個目錄，在檔案總管中，在 C:\Users\user\Documents\DOS\tmp 中建立一個檔案，就會在下次啟動 DOSBox 時，在 C:\tmp 中看到這個檔案。在 DOSBox 中，刪除 C:\tmp 中的一個檔案，和用檔案總管刪除 C:\Users\user\Documents\DOS\tmp 中的同一個檔案，效果一樣。
> 
> 建議：在使用 DOSBox 時儘可能不要去更動 C:\Users\user\Documents\DOS 中的檔案，最好把 DOSBox 關掉後再更動。更動後，重啟 DOSBox ，更動過的檔案才會在 DOSBox 中顯現新的變動內容。

autoexec.bat 檔案建好後，請將下列命令加入 DOSBox 設定檔案的最後面，如下圖：

    autoexec.bat

![](./Images/2024-07-21-14-06-51-image.png)

#### MSDOS 常用命令介紹

所有的 DOS 命令都不分大小寫，你打入小寫指令也沒問題。

1. DIR ： 查看當前目錄內容，後面如果有接目錄，則查看該目錄內容，例如 DIR Z:\。有時目錄下的檔案太多，可以用 DIR /p 分頁查看，或用 DIR /w 橫式列表查看， DIR /p/w 可一起使用。

2. CD 欲切換目錄：改變當前目錄為欲切換目錄，例如 CD C:\DOS4 可切換到 C:\DOS 下，如果只打 CD DOS4 則是在當前目錄下找 DOS4 目錄，如果有則切換到該目錄，如果沒有，則報錯。

3. MD 欲建立目錄：建立新的目錄，例如 MD C:\temp 會建立新的目錄，如果只打 MD temp ，則是在當前目錄下建立新的 temp 目錄。

4. RD 欲刪除目錄：刪除目錄，該目錄中必須是空的，例如 RD C:\temp 會將該目錄刪除，如果只打 RD DOS4 則是在當前目錄下找 DOS4 目錄，如果有則刪除該目錄，如果沒有，則報錯。

5. CLS：清除螢幕。

6. TYPE 檔案：可以顯示檔案內容出來看，有時用編輯器看內容更方便。

7. VER：查看目前的 DOS 版本。

8. COPY 來源檔案 目的檔案：把來源檔案拷貝成目的檔案，例如 COPY C:\tmp\hello.c C:\temp\aaa.c 會將 C:\tmp 中的 hello.c 拷貝到 C:\temp 中成為 aaa.c，如果不打目的檔名，例如 COPY C:\tmp\hello.c C:\temp\ 則是將 C:\tmp 中的 hello.c 拷貝到 C:\temp 中成為 hello.c ，也可以同時拷貝很多檔案，例如 COPY C:\tmp\*.* C:\temp\ 會把所有在 C:\tmp 中的檔案貝到 C:\temp 中

9. DEL 檔案：刪除檔案，例如 DEL C:\temp\hello.c ， 如果只打 DEL hello.c 則是在當前目錄下找 hello.c 檔案，如果有則刪除該檔案，如果沒有，則報錯。

10. RN 欲更名檔案 新檔案名稱：更改檔案名稱，例如 RD hello.c aaa.c 會把當前目錄下的 hello.c 檔案改名為 aaa.c。

有人覺得這樣打指令很麻煩，這也沒辦法，當年只有命令提示字元，就只能這樣打命令。現在，你大可用 Windows 10 的檔案總管去拷貝、刪除、更名目錄或檔案，不用這些命令也沒關係(若將來改用其它模擬器時，這招則未必管用)。 

> DOSBox 也可在 Android 手機或平板上使用，出門在外帶個平板就可以開始寫各種各樣的程式了，這不會只是玩玩小玩意而已，要在 DOSBox 中寫一個完整的編譯器或遊戲是一點問題都沒有的，我都用平板 DOSBox 查看 Gnu C 編譯器原始碼並編譯。
> 
> Android 中使用 DOSBox 的方法寫在後面附錄 A

#### 下載及安裝 DJGPP

DJGPP project 是將 Gnu 的開發工具移植到 DOS 中的計劃，似乎一直有在進行，網路上官網中的下載資料中，可看到 gcc 似乎有移植到 10.0 版了，對我們來說用太新的版本也不好，太新的 C 編譯器去編譯 1980 年代的程式，常常會出問題，那個年代的 C 程式並不遵守什麼 C99 的標準，所以先不要用太新的 gcc 版本，用當年的編譯器就很好，可以一步一步從舊版 gcc 慢慢編譯上來新版的 gcc。

為何要先安裝 DIGPP gcc 編譯器? 因為我們要用的 as86, ld86 組譯器及連結器只有原始檔，要先用 gcc 編譯器去編譯它們的原始檔，才會有 as86 組譯器可以在 DOS 中使用。

當然，用舊版的編譯器或組譯器來編譯現在的程式，也是不行，那時的編譯器也不懂現今新的語法，當然也有問題。

至於那個版本最好，都不要太計較，因為人不是神仙，任何一個版本也都可能還有 bugs 存在，我們也不應該擔心這個，不是都有原始碼在那裡嗎?山不轉路轉，路不轉人自己要轉，看看程式出錯在哪裡，自己去修改程式符合自己的需求才好。

總而言之，用下列網址下載 DJGPP 軟體來安裝，這個好處是，它是一個光碟映像檔(.ISO檔)，可以直接在 Windows 10 中掛載來用，而且在 DOS 中支持 DOS、Windows 3.1 的安裝，很是方便，更重要的是，裡面連原始程式碼都有，對我們的研究之心來說，都是寶貝。

[DJGPP Development System (August 1998) : Free Download, Borrow, and Streaming : Internet Archive](https://archive.org/details/DJGPP_Development_System_August_1998)

連到網站後，稍微向下移，找到如下圖中的 ISO IMAGE ，點下去就可下載，不用擔心病毒，因為它是在模擬器中使用，就算在模擬器中中毒，因為模擬器中的 DOS 沒有網路，病毒想跑出到 Windows 10 將極不可能，除非...。

![](./Images/2024-07-21-14-27-25-image.png)

下載完成後，在「下載」資料夾(C:\Users\user\Download)中，有一個 DJGPP_Development_System_August_1998.iso 檔案，如下圖，在其上連點二下，即可掛載到你的 Windows 系統上：

![](./Images/2024-07-21-14-34-39-image.png)

至於會成為哪一個磁碟，可以用檔案總管看一下，例如我的系統就掛載到了 H:\，直接進 DOSBox 來操作，執行 DOSBox 後，輸入下列命令來開始安裝 DJGPP 軟體：

    z:\mount d: h:\
    d:
    install

上述命令第一行是用 z:\ 中的 mount 程式(z:\ 是 DOSBox 放它提供的程式之處，例如 mount 命令是 DOSBox 提供給我們的命令)將外部 Windows 資料夾 h:\ 掛載到內部 DOS 的 d:，第二行命令將工作目錄切換到 d: 磁碟，d: 磁碟中是我們掛載上來的 DJGPP 光碟片，裡面的 setup 程式是 Windows 3.1 中執行的安裝程式，install 則是 DOS 命令提示字元中使用的安裝程式。

> 前面有時會看到命令和指令二詞，以我自己的概念來說明：
> 
> 命令(Command)：在 DOS 下執行的內部或外部程式，我會用命令來描述，因為是在命令提示字元中輸入來開始執行，例如 debug。
> 
> 指令(Instruction)：在不同語言或軟體中，要求電腦做一件事，我會用指令一詞來描述，例如 C 語言指令 printf ，或組合語言指令 mov 。

install 執行起來後，如下圖所示：

![](./Images/2024-07-21-14-52-11-image.png)

按下 Enter 鍵繼續，待出現如下畫面時：

![](./Images/2024-07-21-14-53-47-image.png)

先不做選擇直接按 Enter 鍵繼續， 此時會開始進行安裝，但 DOSBox 會當掉，不確定是因為什麼原因而起，較有可能是 DOSBox 沒能模擬好 386 保護模式，DJGPP 的軟體大多是要在 DPMI 完整提供下才能成功執行，而 DOSBox 沒能成功。

安裝不成功，為何還要寫這段，因為將來使用別的模擬器(例如 Bochs)，就可以用這個方法安裝使用。那麼現在該怎麼辦呢?

其實有更簡單的安裝辦法，回到檔案總管，在 DJGPP 掛載的磁碟中，例如我的是 h:\ 磁碟，有一個 DJGPP 目錄，把它整個目錄 copy 到 C:\Users\user\Documents\DOS 中即可。拷貝完成後，順道在 DOS 目錄下新增一個 tmp 目錄。如下圖：

![](./Images/2024-07-21-15-21-04-image.png)

接著用記事本編譯 autoexec.bat，修改如下：

    set path=c:\dos4
    set PATH=c:\djgpp\bin;%PATH%
    set DJGPP=c:\djgpp\djgpp.env

第一行是原本的內容，後二行是為了能執行 DJGPP 的體所加入。

至此，基本的 DJGPP 應該已經安裝好了，後面會教你把缺的補齊，做法是缺什麼補什麼，明明白白地理解缺的東西是什麼，又有何用處。首先，要試看看安裝進去的東西最少能做什麼，請在 C:\Users\user\Documents\DOS\tmp\ 目錄(即資料夾 directory)中用記事本建立一個 hello.c 的檔案，內容是：

    #include <stdio.h>
    
    void main(void) {
        printf("Hello, world!\n");
    }

![](./Images/2024-07-21-15-32-12-image.png)

打好程式後存檔，如上圖所示，然後打開 DOSBox ，依下圖所示操作：

![](./Images/2024-07-21-16-59-33-image.png)

只要看到如上圖的結果就知道安裝的 DJGPP 沒有問題，編譯 hello.c 成為 DOS 下的 hello.exe 沒問題，所以編譯過程中須要的 include 檔及 library 檔案也都找得到，不會建置不成功，這樣就可以進行下一步了。

## 第2章 as86 程式下載及安裝

 Linux 作業系統當初發明時，是用 as86 組合語言寫開機載入程式(Boot Loader)，為了能打好理解該程式的基礎，所以要先學 as86 組譯器，如果你對 8086 組合語言沒有興趣，則完全直接略過本書。 

#### as86 及 ld86 程式下載及安裝

到下列網址中，下載其中的 bin86-0.1.tar.gz：

[Index of /slackware/slackware-2.0.0/source/d/binutils](https://mirror-hk.koddos.net/slackware/slackware-2.0.0/source/d/binutils/)

下載完畢後將 bin86-0.1.tar.gz 用 7-zip 解壓，把解壓後的 bin86-0.1 資料夾拷貝到 C:\Users\user\Documents\DOS\tmp 中，

    cd c:\tmp\bin86-0.1
    ren a~1.h aout.h
    cd aout.h
    ren a~1.h aoutgnu.h
    ren bsd-a~1.h bsdaout.h

上述 DOS 命令是因為下載的原始碼檔案都是長檔名，在 DOS 下要改成 8.3 格式的檔名才可以使用，最終如下圖所示：

![](./Images/2024-07-23-07-00-59-image.png)

改過後，可想而知原始碼中有些地方使用到這些長檔名的地方，都要改成這種 8.3 格式的檔名，首先

    cd c:\tmp\bin86-0.1\as
    edit makefile

用編輯器(你可以用記事本打開來看及編輯)查看其內容，內容如下，那些編譯的選項都可以不要，只要編譯出來可以執行就好，所以要將 makefile 修改一下。

![](./Images/2024-07-23-07-03-05-image.png)

修改完後，如下圖，可以這樣修改有它的原因：

1. 我們用的 gcc 已經是 DOS 下的 gcc，它自然會產生 DOS 的執行檔，不要再指定產生的執行檔的格式。

2. 當然也不要指定 gcc 編譯 486 CPU 的指令，gcc 自己會知道它是要編譯 DOS x86 的執行檔。

3. 不管最後的 as86.exe 在使用時(組譯組合語言程式)，能不能正確生成 a.out 檔，並不重要，我們只是要用它組譯程式以產生目的檔 (OBJ 檔)，所以 aout.h 跟本不重要。

![](./Images/2024-07-23-07-09-22-image.png)

按上面修改後，回到 DOS 命令提示字元，輸入下列命令即可編譯出 as86.exe 檔。

    make

過程中的 warning 都不要理它了，最早一版的 as86 也不用期望它沒有 warning 。編譯完後，可以把它拷貝到 c:\djgpp\bin 中：

    copy as86.exe c:\djgpp\bin

這樣 as86.exe 就搞定了，至少我們有一版可用的 8086 組譯器了，我們後面會用它來學 8086 的組合語言。

接下來要處理 ld86 了，同樣先用下列命今切換到 ld 的原始程式目錄：

    cd c:\tmp\bin86-0.1\ld
    edit makefile

同樣先用編輯器來改 makefile 的內容，大致原理同上所述：

![](./Images/2024-07-23-07-22-06-image.png)

改完的 makefile 如下：

![](./Images/2024-07-23-07-27-43-image.png)

編譯選項保留了 -DBSD_A_OUT 是因為最後編譯出的 ld86.exe ，在使用它來連結目的檔以產生執行檔的時候，產生的執行檔不論是何種格式，應該都不能在我們 DOS 下執行，關於這點先不管它，重要的是先編譯再說，接著用下列命令開始編譯：

    make

可想而知會出現一些問題，我們都沒動到任何原始程式，至少先前那個 bsd-a~1.h 我們把它改名成 bsdaout.h ，這在原始程式某處一定不行過，先編譯看問題在哪裡，結果如下圖，type.h 檔有點問題。

![](./Images/2024-07-23-07-26-48-image.png)

我們用編輯器來打開 type.h ，找到 175 行 umask 的段落，如下圖：

![](./Images/2024-07-23-07-35-46-image.png)

出問題的那段是在 #ifdef MY_STAT_H ，我們用系統的 sys/stat.h 就好，直接把這段註解掉，如下圖。

![](./Images/2024-07-23-07-37-42-image.png)

不刪除它的原因是如果改錯了，還能改回來，另外不要用 /* ... * / 來註解掉這段，因為它裡面已經有 /* ... */ 了，當時的 gcc 不確定可以巢狀註解，不要自找麻煩。

改完後，再重新 make ，結果如下圖，不出所料，writebin.c 找不到 bsd-a.out.h 檔，先自己把第 18 行改成 bsdaout.h

![](./Images/2024-07-23-07-42-44-image.png)

改完後再次 make 出現下圖問題：

![](./Images/2024-07-23-07-47-14-image.png)

再次編輯 type.h ，找到第 204 行 #include <unistd.h> 將其註解掉。重新 make，出現如下圖問題：

![](./Images/2024-07-23-07-49-49-image.png)

上網查一下，是因為 R_OK 定義在 unistd.h 中，而它被我們在前面(type.h中)給註解掉了，沒關係，反正 R_OK 是定義為 4，你可以把它直接改成 4 ，或在 ld.c 的最前面用 

    #define R_OK 4

自己定義它，再次 make 編譯，出現一列問題：

![](./Images/2024-07-23-08-03-46-image.png)

這次是在 bsdaout.h 檔中找不到 a.out.gnu.h 了，這就靠你自己去改了，編輯 bsdaout.h 將 a.out.gnu.h 改為 aoutgnu.h。

最後再用 make 就可以產生 ld86 了，但是這個 ld86 產生的執行檔完全不能在 DOS 下使用，我們要先改 writebin.c 檔案，令其寫出執行檔時，不要加入 a.out 格式標頭到輸出的執行檔案中。

as86 及 ld86 原本就不是用來寫大程式，在 DOS 下面寫個小程式(如 .com 檔案)尚且可用，ld86 最後連結出來的執行檔是包含 MINIX 執行檔(excution file)檔頭(header)的部份，尤其下載來的原始程式版本用 gcc 編譯出來的 ld86.exe 程式，在連結 as86.exe 產生的目的檔(object file)時，都會加上 MINIX 作業系統的檔頭部份，這在 DOS 下跟本無法使用，所以我們就直接改 ld86 的原始碼，讓它不要輸出檔頭資訊即可。

除了檔頭外，ld86 還會輸出符號表，這不須要改程式，只要在使用 ld86.exe 時加上 -s 即可令其不輸出符號表，經由這樣改造後的 ld86.exe 基本上輸出的就類似 .com 的檔了。(完全只有原始組合語言翻譯出來的機器碼的檔案)

要改造的 ld86 原始程式碼只有一個 writebin.c 檔，用文字編輯器打開 writebin.c，找到如下程式碼段落，把最後那行 writeout 程式註解掉即可。

```
#ifdef MINIX

PRIVATE void writeheader()
{
    struct exec header;

    // printf("MINIX\n");
    memset(&header, 0, sizeof header);
    header.a_magic[0] = A_MAGIC0;
    header.a_magic[1] = A_MAGIC1;
#ifdef BSD_A_OUT
    if (!reloc_output)
#endif
    {
    header.a_flags = sepid ? A_SEP : A_EXEC;
    if (uzp)
        header.a_flags |= A_UZP;
    }
#ifdef BSD_A_OUT
    header.a_cpu = (bits32 || reloc_output) ? A_I80386 : A_I8086;
#else
    header.a_cpu = bits32 ? A_I80386 : A_I8086;
#endif
    header.a_hdrlen = FILEHEADERLENGTH;
    offtocn((char *) &header.a_text, etextpadoff - btextoffset,
        sizeof header.a_text);
    offtocn((char *) &header.a_data, edataoffset - bdataoffset,
        sizeof header.a_data);
    offtocn((char *) &header.a_bss, endoffset - edataoffset,
        sizeof header.a_bss);
#ifdef BSD_A_OUT
    if (!reloc_output)
#endif
    {
    if (uzp)
        offtocn((char *) &header.a_entry, page_size(),
            sizeof header.a_entry);
    offtocn((char *) &header.a_total, (offset_t)
            (endoffset < 0x00010000L ? 0x00010000L : endoffset + 0x0008000L),
        sizeof header.a_total);
    }
    //writeout((char *) &header, FILEHEADERLENGTH);
}
```

修改完 writebin.c 程式後，再次 make 即可產生我們要的 ld86.exe，接著把它拷貝到 c:\djgpp\bin 中，

    copy ld86.exe c:\djgpp\bin
    cd c:\tmp

as86.exe 及 ld86.exe 都拷貝到 c:\djgpp\bin 中後，我們要先測試看看它們有沒有大問題，請先切換到 c:\tmp 目錄，而後輸入下列程式，存成 outText.s 組合語言檔案：

```
export _main
.text
_main:
        jmp start
msg:
        .ascii "Hello"
start:
        mov     cx, #5
        mov     dl, #0x00
        mov     dh, #0x05
        mov     ax, #msg
        add     ax, #0x100
        mov     bp, ax
        mov     bx, #0x000c
        mov     ax, #0x1301
        int     0x10
        mov     ax, #0x4c00
        int     0x21
.data
.bss
```

接著用下列命令加以組譯：

```
as86 -0 -o outText.o -l outText.lst outText.s
```

-0 是指定組譯成 8086 的機器碼，如果不指定，ax 會被譯成 eax，-3 則指定譯成 80386 的機器碼

-o 後面接目的檔名

-l 後面接列表檔的檔名，列表檔會將組譯的結果以文字形式列印出來，方便查對程式是否正確(也可能是 as86 自己出錯)

組譯完成後，會產生一個 outText.o 的目的檔，接著就可用下列命令來產生一個 outText.com 的可執行檔了：

```
ld86 -0 -s -o outText.com outText.o
```

-0 影響標頭的一個 magic word，代表產生的是 16 bits 執行檔， -3 代表 32 bits ，但因為我們改成不輸出標頭，所以不影響執行檔結果。(在 MINIX 下使用 ld86 產生執行檔就有影響)

-s 指定不輸出符號表，只產生原始機器碼檔案，這個選項很重要一定要打

-o 後面指定輸出的執行檔名

產生執行檔後，因為是完全 16 bits DOS .com 檔案，所以可以放心用 debug 去做除錯，當然也可以直接執行查看結果，執行結果如下：

![](./Images/2024-08-07-11-57-48-image.png)

這個程式只是測試用，只要你照著前面的過程做下來，畫面都跟我的一樣，那就表示 as86 及 ld86 沒有問題了，關於這個程式的每個指令的意義及說明，則要等到後面的章節。

> 以上產生 as86 及 ld86 的過程也許令你覺得厭煩，但這是成長必經之路，所有程式設計師每天都是在這樣的錯誤或那樣的問題中，掙扎向前，沒有什麼人應該為你準備好一切，除了 M$ (Give me money and I will give you Microsoft)，但你確定微軟給你的東西就沒有問題嗎?你又沒看到它給你的程式的原始碼?你是如何說服自己相信他們的呢?
> 
> 2024/07/19 的事件再次浮現我眼前。

#### bcc x86 C 語言編譯器下載及安裝

其實這段和本書有點脫節，可是 as86、ld86 和 bcc 常合在一起稱為 bin86 或 dev86 工具，所以在這裡順便把 bcc 編譯器也做出來，以寫組合語言程式來看，的確用不上，但用它來觀察 C 編譯器編譯出的組合語言碼，也是一種學習。

前面下載的 bin86 中，因為版本太早了(也可能是其它因素)，並沒有包含完整的 bcc 編譯器程式，所以我們要到下列網址中去下載：

https://github.com/lkundrak/dev86

打開該網頁後，請在「<> Code 」上按一下，會出現如下圖結果，請點擊「Download Zip」將 dev86 專案下載。

![](./Images/2024-07-23-06-09-33-image.png)

下載完 dev86 後，在下載資料夾中會有一個 dev86-master.zip 的檔案，請將其解壓縮，而後將整固 dev86-master 解壓目錄貝到 C:\Users\user\Documents\DOS\tmp 中，打開 DOSBox 模擬，執行下列命令：

    cd c:\tmp\dev86-~1\bcc

編輯 makefile 內容成為下列結果：

    #
    # bcc Makefile
    # $Id$
    #
    
    PREFIX=/usr
    
    CFLAGS  =-O -w
    LDFLAGS    =-s
    BINDIR    =$(PREFIX)/bin
    LIBDIR    =$(PREFIX)/lib/bcc
    BCCDEFS =
    
    BCFLAGS=$(ANSI) $(CFLAGS) $(LDFLAGS)
    
    OBJS = bcc-cc1.o codefrag.o dbnode.o declare.o express.o exptree.o floatop.o \
        function.o gencode.o genloads.o glogcode.o hardop.o input.o label.o \
        loadexp.o longop.o output.o preproc.o preserve.o scan.o softop.o \
        state.o table.o type.o assign.o hashcmd.o debug.o dbprintf.o
    
    all:    bcc-cc1 bcc 
    
    install: all
        install -d $(BINDIR)
        install -m 755 bcc $(BINDIR)/bcc
        install -d $(LIBDIR)
        install -m 755 bcc-cc1 $(LIBDIR)/bcc-cc1
    
    bcc: bcc.c
        $(CC) $(BCFLAGS) $(BCCDEFS) bcc.c -o $@
    
    ncc: bcc.c
        $(CC) $(BCFLAGS) -DLOCALPREFIX= -DDEFARCH=0 bcc.c -o $@
    
    bcc09: bcc.c
        $(CC) $(BCFLAGS) -DMC6809 $(BCCDEFS) bcc.c -o $@
    
    ccc: bcc.c
        $(CC) $(BCFLAGS) -DCCC $(BCCDEFS) bcc.c -o $@
    
    bcc-cc1: $(OBJS)
        $(CC) $(BCCARCH) $(LDFLAGS) $(OBJS) -o bcc-cc1
    
    debug.o: debug.c debug.h
        $(CC) $(ANSI) $(BCCARCH) $(CFLAGS) -c debug.c
    
    dbprintf.o: dbprintf.c
        $(CC) $(ANSI) $(BCCARCH) $(CFLAGS) -c dbprintf.c
    
    clean realclean:
        rm -f bcc bcc-cc1 ncc bcc09 ccc bcc.o $(OBJS)
    
    
    $(OBJS):  bcc.h align.h const.h types.h \
              byteord.h condcode.h gencode.h \
          input.h label.h os.h output.h \
          parse.h proto.h reg.h sc.h scan.h \
          sizes.h table.h type.h
    
    .c.o:
        $(CC) $(BCCARCH) $(CFLAGS) -c $<
    然

 然後編輯 bcc.c 檔案，將 #include "version.h" 這行註解掉，總共有二處。註解掉後存檔，回到 DOS 提示字元下，再次用

    make

開始編譯 bcc 程式，編譯完成後，用下列命令將 bcc 程式貝到 c:\djgpp\bin 中，

    copy bcc-cc1.exe c:\djgpp\bin
    copy bcc.exe c:\djgpp\bin

至此，我們就可以測試 bcc 編譯 C 語言程式的能力，先切換到 c:\tmp 目錄下，而後輸入以下程式，存檔為 test.c：

    main() {
            int a;
            a=4+7;
    }

接著用下列命令將 C 語言原始碼編譯成 x86 (16 bits) 組合語言程式碼，

    bcc-cc1 -0 test.c -o test.s

> 不使用 bcc 而是使用 bcc-cc1 的原因是，因為 bcc 只是 C 編譯器的驅動器，有關 C 編譯器的驅動器概念，會在另一本我寫的書中介紹，總之 bcc-cc1 才是真正 C 語言的編譯器。
> 
> 事實上，你透過下面的例子，大致也可以感覺到整個編譯的過程了。

編譯出的 8086 組合語言碼如下：

    export    _main
    _main:
    !BCC_EOS
    push    bp
    mov    bp,sp
    push    di
    push    si
    dec    sp
    dec    sp
    mov    ax,*$B
    mov    -6[bp],ax
    !BCC_EOS
    inc    sp
    inc    sp
    pop    si
    pop    di
    pop    bp
    ret
    .data
    .bss
    
    ! 0 errors detected

如果要編譯成 80386 組合語言程式碼，則可將 -0 換成 -3 即可

編譯出的組合語言碼如下：

    export    _main
    _main:
    !BCC_EOS
    push    ebp
    mov    ebp,esp
    push    edi
    push    esi
    push    ebx
    add    esp,*-4
    mov    eax,*$B
    mov    -$10[ebp],eax
    !BCC_EOS
    add    esp,*4
    pop    ebx
    pop    esi
    pop    edi
    pop    ebp
    ret
    .data
    .bss
    
    ! 0 errors detected

要進行組譯(以 8086 test.s為例)，可以使用如下命令：

    as86 -0 -o test.o -l test.lst test.s

產生的 test.lst 列表如下：

    00001                                           export    _main
    00002                       00000000>           _main:
    00003                                           !BCC_EOS
    00004 0000           55                         push    bp
    00005 0001           89E5                       mov    bp,sp
    00006 0003           57                         push    di
    00007 0004           56                         push    si
    00008 0005           4C                         dec    sp
    00009 0006           4C                         dec    sp
    00010 0007           B8                   000B  mov    ax,*$B
    00011 000A           8946         FA            mov    -6[bp],ax
    00012                                           !BCC_EOS
    00013 000D           44                         inc    sp
    00014 000E           44                         inc    sp
    00015 000F           5E                         pop    si
    00016 0010           5F                         pop    di
    00017 0011           5D                         pop    bp
    00018 0012           C3                         ret
    00019 0000                                      .data
    00020 0000                                      .bss
    00021                                           
    00022                                           ! 0 errors detected
    
    Symbols:
                         _main  0 0000 R E 
    
    00000 errors
    00000 warnings

然後用下列命令產生可執行檔：

    ld86 -0 -s -o test.com test.o

這個範例不好拿來直接執行，因為沒有輸出可看(要看到輸出要有 bcc 的標準庫)，但可以用 debug test.com 命令查看它的結果，如下圖所示：

![](./Images/2024-07-23-13-33-55-image.png)

關鍵的是 06F2:0107 及 06F2:010A 這二行這就是 a=4+7; 那行是 C 語言的編譯結果，可以看出 bcc 會先把 4+7 算好，再放入到 a 中，而不是用組合語言指令去做實際的加法：

        mov ax,4
        add ax,7
        mov [bp-6],ax

有關 bcc 的使用及 C 語言的介紹，不是本書範圍，但我會另出一本有關 bcc/gcc 的 C 程式設計的書來專門介紹它。

## 第3章 8086 組合語言程式設計基礎概念

#### 組譯及連結

經過前面的範例，你應該知道組合語言程式經過 as86 組譯器的處理後會變成目的檔，還要經過 ld86 的連結才能變成執行檔，為何不用一個程式就直接產生執行檔不好嗎?

好也不好。

好的原因是自己一個人寫程式，只寫一個組合語言程式，直接組譯就可以成為執行檔，很方便。

不好的原因是，如果案子很大，一個人做太久，就要幾個人分成幾個程式來寫，這樣每個人可以分別組譯，看看有沒有組合指令用錯了，或語法上的其它問題，這樣可以加快開發速度。

即使是一個人，也總有一天要寫大的程式，也總有一天要會把大程式拆成不同的檔案來各別組譯，這樣組譯器及連結器分開就有意義了，下圖就是一個例子，說明組譯及連結的意義。

![](./Images/2024-07-23-13-57-47-image.png)

事實上，要把組譯器及連結器弄成一個程式也沒有問題，這個程式就叫做驅動器，例如前面提到的 bcc 及 gcc 就是驅動器，它們只是把不同的程式拿來，幫你叫用編譯器、組譯器及連結器，以產生執行檔。

我認為初學者就是要在使用多次 as86 及 ld86 後，自己體驗出不同工具的詳細使用方法，之後使用驅動器就會得心應手了。

#### 電腦的基本架構 ─ 記憶體

在開始寫組合語言之前還是要先把電腦的基本架構交代一下，如果你大致知道電腦的架構，那可以直接跳過這段，寫組合語言不是只用一段架構說明就能講清楚，學習過程中會不斷地出現須要補充的知識，不用急於一時弄清楚。

電腦中的程式經編譯或組譯後，會放在硬碟中，形成一個檔案，當要執行時會由作業系統(Operating System, OS)載入到記憶體(RAM)中，而後由 CPU 一個指令(機器碼)一個指令地從記憶體中取出來執行。故而記憶體中存放有機器碼指令，CPU 指令執行時所須要的資料也是要從記憶體中取得，運算完的結果也會先存在記憶體中，所以記憶體中有指令碼(Instruction code)及資料(Data)。

![](./Images/2024-08-01-18-30-42-image.png)

記憶體在電腦中可以看成是一格一格的格子，每個格子有一個號碼，從0x0000號開始(電腦中通常從0始編號，不是從1開始)，下一個格子號碼遞增 1，直到最後一個格子。由於每個電腦的記憶體大小不一定，因此最後一個格子的編號通常也不會一樣。

以上圖來說，記憶體的大小是 0x0000 ~ 0xFFFF 共 64K 個位元組。每個記憶體格子中可以放一個位元組(即 8 個位元)的內容，記憶體的內容可能是機器碼指令或資料。

記憶體若是 RAM，則其內容可以變更，也就是可以隨著程式的進行而改變其內容。也有不可以改變內容的記憶體，稱為 ROM，通常是由電腦硬體隨附而來的程式，例如 BIOS 或 UEFI 開機程式，電腦在通電開機後，不論有沒有硬碟，主機板上都有 ROM 的程式，CPU 會從其中讀取機器指令來開始運行。

#### 電腦基本架構 ─ Intel 8086 CPU

Intel 8086 CPU 是學習 16 位元 x86 組合語言的 CPU，在它之前 Intel 還有出過 4040、8080   等 CPU，分別是 4、8 位元的 CPU，也就是說即使是硬體廠商，也要從最基本的硬體先計出來，才會往更複雜的硬體架構前進。

8086 CPU 因為是 16 位元 CPU，所以它存取記憶體時，位址之值可以有 16 個位元，即 0x0000 ~ 0xFFFF，共有 64KB，CPU 硬體可以另外再加上一個 16 位元的分段暫存器的值，使存取記憶體時的位址值可以大於 64KB，下圖為 8086 CPU 內部基本架構圖(取至 Intel 8086 datasheet)：

![](./Images/2024-08-03-08-18-48-image.png)

這種硬體功能區塊圖對初學者而言，不是一眼就能看懂及掌握，在此只針對較重要的部份講解。

首先看到右邊的中間有 AD0 - AD15 的匯流排(BUS)，所謂匯流排可看成是一排的電線，例如 AD0 - AD15 就是指 16 條電線，分別叫做 AD0、AD1、... AD15，這就是連到 CPU 外部記憶體的位址線，它有二種作用，另一種是當作資料線。CPU 利用其它的電線(AD0下面那些)，可以讓外部記憶體知道目前在這 16 條電線上是位址或資料，詳細的控制信號在此不用理解，除非本書是介紹數位邏輯或電腦硬體架構的書，在這裡只要知道 CPU 對記憶體的操作基本有二種：

1. CPU 從記憶體中讀取資料：CPU 把位址放到 AD0 - AD15 上，而後控制記憶體(下達讀取命令)把該位址內容放到 AD0 - AD15 上，而後讀到 CPU 內部暫存器中。

2. CPU 把資料寫入記憶體中：CPU 把位址放到 AD0 - AD15上，而後控制記憶體鎖定位址，再把資料放到 AD0 - AD15 上，然後對記憶體下達寫入命令，資料即進入到記憶體內部。

> 上圖中的 A15 - A19 線可以看成是結合了分段(segmentation)技術後，可以擴大位址線的數量，從而超越 64KB 的大小。 
> 
> 另外，結合其它控制線，也可以只存取 8 位元的資料，即 AD0 - AD7 或 AD8 - AD15。

在上面的說明中，最重要的是「位址」及「資料」二個詞，其餘都是抽象細節，由於不是具體細節，有點搞不清楚也沒關係，重要的是 CPU 利用「位址」向記憶體讀寫「資料」就對了。

前面提到了 CPU 中的暫存器，那麼它到底是什麼呢?你可以把它看成是 CPU 中的記憶體，由於數量不多，所以不是用位址的方式描述它的定位，而是用名稱的方式來定位它們，以上圖來看是位於上方 REGISTER FILE 及 RELOCATION REGISTER FILE 功能區塊中。

我們用下圖來說明， 8086 CPU 中這些暫存器的名稱各是什麼：

![](./Images/2024-08-03-08-54-40-image.png)

CPU 中的最重要部件是稱做 ALU (算術邏輯單元)的東西，在功能區塊圖的左邊中間有一個 16 BIT ALU，它是執行邏輯及算術運算地方，它會從上圖中的暫存器或外部記憶體取資料來做算術或邏輯運算，運算完的結果會再存回暫存器或外部記憶體中。

上圖中 AX, BX, CX, DX 暫存器是 16 位元大小的暫存器，它們各別可以分成上下半部成為 2 個 8 位元的暫存器，例如 AX 可分成 AH 及 AL 暫存器。這 4 個暫存器各有自己的名稱，雖然它們實際上功能各不相同，這可以由它們的全名(例如 ACCUMULATOR REGISTER=AX)看出來，但我們基本上可以把這 4 個暫存器看成一般暫存器，可以用來存放 ALU 計算前後的資料。

SP, BP, SI, DI 則通稱指標或索引暫存器，詳細功能等後面講解組合指令時，自然會介紹到它們的作用。CS, DS, SS, ES 是分段暫存器，就是前面說過用來擴大記憶體定址範圍的暫存器，有關記憶體定址在後面會再介紹。

IP 是指令指標暫存器，它是 CPU 中記錄目前正在執行的指令之位址的暫存器，例如它的值若是 0x0100，就表示目前將要執行的指令是記憶體位址的 0x0100 中的指令。

ALU 做完算術或邏輯運算後，除了結果外還會有另外的資訊須要記錄下來，例如 0xFFFF + 0x0001 = 0x10000，這在 16 位元電腦中已經超過 16 位元大小了，所以結果會變成 0x0000，並存回指定的一般暫存器中，若只做這樣的動作，就會有資訊遺漏了，所以那個超過的資訊稱為溢位，ALU 也會把它記下來，記錄的地方就是功能區塊圖中 ALU 下方的 FLAGS 區塊，相對暫存器來說，就是上圖中的 STATUS FLAGS 。

後面真正撰寫組合語言程式時，會對這些暫存器的使用及真正意義再加以說明。

#### 電腦基本架構 ─ 簡單架構

電腦的架構中，除了主要的 CPU 及記憶體外，還有其它支持的硬體元件，否則電腦是無法運行的，如果說明太複雜的電腦架構又會偏離本書主題，所以就以下圖(取至 Intel 8086 datasheet)講解和組合語言有關的硬體元件。

![](./Images/2024-08-03-08-52-38-image.png)

8086 CPU 只能做整數的運算，它不包含有浮點數的硬體運算器，故上圖中以簡單的 CPU 和外部硬體元件的連結為主。

1. 8284A (圖中最左上角)：硬體元件是一個時鐘 IC 晶片，利用石英振盪器及電阻電容構成電壓的方波信號 CLK (時脈)給 CPU 使用，時脈信號可以看成是 010101... 由低電壓(0)和高電壓(1)循環不只的信號，電腦的硬體都要在時脈由 0 變 1 或由 1 變 0 的時間開始動作，在下一個 01 變換到來前，硬體要完成該動作，這就是硬體的同步。

2. LATCH (圖中央偏上)：它是用來將 CPU 的 AD0 - AD15 匯流排送出的位址鎖住，由右邊 ADDR 匯流排送出。前面說過，CPU 的 AD0 - AD15 即是資料又是位址，你可以想像在第 T 個時脈時，AD0 - AD15 上面的信號是代表位址，在下一個 T+1 時脈到達前 LATCH 會將其左邊的位址信送到右邊 ADDR 電線上，然後鎖住 ADDR 為 CPU 送出的位址直到下個時脈之後。除了鎖住位址信號外，它還會隔開 AD0 - AD15 線和 ADDR 線，在 T+1 時脈來到時，AD0 - AD15 線上會變成資料，這樣這個資料線的內容就不會跑到 ADDR 線上了。

3. TRANSCEIVER (圖中央偏下)：它是用來把 CPU 的資料送到右邊 DATA 匯流排上，或者把 DATA 匯流排上的資料送到左邊 AD0 - AD15 上。它是一個雙向的緩衝器，資料的方向由 DIR 接腳控制，當 CPU 到寫入資料到 RAM 時，會於時脈 T 將位址放到 AD0 - AD15 上，然後由 LATCH 鎖住位址在 ADDR 匯流排上，下一個 T+1 時脈，CPU 將資料放到 AD0 - AD15 上，而後 TRANSCEIVER 將資料送到 DATA 匯流排上，RAM 就會把資料放入到位址所指定的記憶體中了。相反，當 CPU 要從 RAM 讀取資料時，則是 CPU 送出位址，而後 LATCH 鎖定位址，RAM 將該位址的資料取出放到 DATA 匯流排上，而後 TRANSCEIVER 將 DATA 線上的資料放到 AD0 - AD15 上，由 CPU 取走。

> 以上和位址線有關的部份都不提及 A16 - A19，原因是它們純粹是位址線，上面不會出現資料，所以不論哪個時脈，LATCH 只是把它們直接送到 ADDR 線上。

4. RAM (圖右下最左塊)：它是可以讀取(OD線)及寫入(WE線)資料的記憶體區塊，作業系統及一般的應用程式要從硬碟先放到記憶體中才可以由 CPU 執行，執行程式所產生的資料，也要先存放在 RAM 中，才能放回硬碟中。在 RAM 中的資料在電腦關機(沒電)時，會消失不見，要等下次開機再由硬碟中取回。

5. ROM (圖右下中間區塊)：它是只可以讀取資料的記憶體區塊，主要是電腦開機時立即要執行的程式所在的記憶體，它裡面的資料不會因為關機(沒電)而消失，通常是放 BIOS 或 UEFI 啟動程式，ROM 中的程式主要在電腦啟動時，對硬體做一個檢測，而後去硬碟中載入作業系統到 RAM 中，而後把電腦執行權交給作業系統。

6. PERIPHERAL (圖右下最右邊區塊)：它是周邊設備的連結硬體元件，主要可以把外接周邊設備看成類似記憶體一般，每個設備有它自己的 I/O 位址線，及 I/O 資料線，I/O 位址線和資料線是和 AD0 - AD15 共用，記憶體和周邊利用 CPU 的 M/IO 線的電位高低知道 AD0 - AD15 上的信號是要給記憶體或 I/O 周邊，只要外接設備發現位址線是和自己有關，就會由 DATA 匯流排拿資料，或把資料送到 DATA 匯流排。CPU 送到外接設備的資料可以是指令或真正的資料，每個設備自己會解讀 CPU 送來的指令，而後根據要求行動，完成資料的傳送。

## 第4章 8086 組合語言指令 ─ MOV

#### 第一個範例程式 ─ mov_ex1.s

看過電腦的基本架構後，  先用一個簡單的範例來示範將資料放入到 CPU 中的暫存器之方法：

    export _main
    .text
    _main:
            mov     ax, #50
            mov     bx, #0x20
            mov     cx, #021
            mov     dx, #-1
            mov     ah, #0x4c
            int     0x21     
    .data
    .bss

先用記事本編輯一個 mov_ex1.s 的檔案，而後在存檔時記得存成 ANSI 的字元檔案，不要存成 UTF-8 或 UTF-16 的字元格式，在 DOS 的年代，英文字元都只佔一個 ASCII 位元組，還沒有 unicode 字元，把上列程式複製到記事本中儲存也可能會出問題，因為空白(SPACE)字元也不保證是 8 位元，如果在 DOS 中組譯出錯，先在 DOS 中用編輯器打開看看。

你可以在 c:\tmp 中建立一個 assembly 目錄，用來存放所有範例檔案。

> 在 DOS 中的編輯器有很多，例如 edit.com ，使用來很簡單，按 Alt + F 即可打開檔案選單，單按 Alt 會把游標移到選單上，可以左右選擇選單項目。
> 
> DJGPP 中也有附一個編輯器 rhide.exe，可以用來編輯程式碼，功能比 edit.com 強大，要使用它，請上網查詢詳細用法。
> 
> 不論 edit.com 或 rhide.exe ，只要有滑鼠，在 DOSBox 中都可以用滑鼠去點選上方選單，使用起來應該沒有難度。

存檔完成後，假設是存於 c:\tmp\assembly\mov_ex1.s ，則用下列命令進行組譯及連結：

    cd c:\tmp\assembly
    as86 -0 -l mov_ex1.lst -o mov_ex1.o mov_ex1.s
    ld86 -0 -s -o mov_ex1.com mov_ex1.o

組譯連結後會產生 mov_ex1.lst 及 mov_ex1.com 檔，可以查看 mov_ex1.lst 的組譯結果：

    00001                                           export _main
    00002 0000                                      .text
    00003                       00000000>           _main:
    00004 0000           B8                   0032          mov     ax, #50
    00005 0003           BB                   0020          mov     bx, #0x20
    00006 0006           B9                   0011          mov     cx, #021
    00007 0009           BA                   FFFF          mov     dx, #-1
    00008 000C           B4                     4C          mov     ah, #0x4c
    00009 000E           CD                     21          int     0x21     
    00010 0000                                      .data
    00011 0000                                      .bss
    
    Symbols:
                         _main  0 0000 R E 
    
    00000 errors
    00000 warnings

> 不同的組譯器，語法格式都不一樣，就如同世界上有許多語言一般，即使是同一個國家，也不是都講同一種語言，所以不要以為學了 as86 的組合語言用法，就可以把 as86 寫的程式直接丟給 gas 去組譯，你肯定會大失所望。
> 
> 但是，基本上所有的組譯器指令格式會大致類似，因為一個組合語言指令都是相對機器碼的好記模式，機器碼只有三個重要部份，
> 
> 1. 指令碼：也就是 CPU 要做的事。
> 
> 2. 資料來源：也就是 CPU 要做事時的資料來源，例如要把記憶體位址 0x0000 的資料放到 CPU 的 AX 暫存器中，這個「記憶體位址 0x0000」就是資料來源。
> 
> 3. 資料目的地：也就是 CPU 做完事後資料的去處，例如要把記憶體位址 0x0000 的資料放到 CPU 的 AX 暫存器中，這個「AX 暫存器」就是資料目的地。
> 
> 把這三個部份拿來設計組合指令格式，大致只有下列二種：
> 
>         指令碼    資料來源, 資料目的地
> 
> 或
> 
>         指令碼    資料目的地, 資料來源
> 
> 指令碼放最前面不用懷疑，正常人都這麼做，人是由前向後看(橫書的由左向右)東西的，雖然也有人可以一眼看完，但還是希望第一眼就看到指令，知道 CPU 要什麼事。剩下就只能排列資料來源及資料目的地的前後關係了，中間用一個分隔符號分開，雖然多數的組譯器是用逗號(,)分隔，但用空白符號也不是不行，如果有看到這樣的組譯器，也不要驚訝。
> 
> as86 是採取第二種格式。

以下說明各指令的意義：

| 組合語言指令        | 說明                                                                                                                                                                                                                                                                                        |
|:------------- |:----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| mov ax, #50   | 把十進制數值放到 ax 暫存器中的意思，50 前的 # 表示 50 是一個數值，而不是記憶體的一個位址，沒有這個 # 號，意義完全不同。B8 0032 是組譯器產生的機器碼，它們都是以十六進制表示，十進制 50 的十六進制是 0x32，列表因為都是十六進制數，所以不用每個數前都加 0x 了。另外 B8 0032 在記憶體中，B8 是放在記憶體相對位址 0x0000 中，32 是 0032 的低位元部份，所以放在記憶體相對位址 0x0001 (低位址)中，最後 00 是 0032 的高位元部份，所放在 0x0002 (高位址)位址中。             |
| mov bx, #0x20 | 把十六進制數值 0x20 放到 bx 暫存器中。                                                                                                                                                                                                                                                                  |
| mov cx, #021  | 把八進制數值 021 放到 cx 暫存器中，八進制 021 換成二進制是 000010001，再換成十六進制則是 0x11。                                                                                                                                                                                                                            |
| mov dx, #-1   | 把十進制 -1 放到 dx 暫存器中，對電腦來說在記憶體中的數值都只能是 0 和 1，8086 是 16 位元電腦所以它的數值以二進制 0, 1 來看，範圍是 0000 0000 0000 0000 ~ 1111 1111 1111 1111，在這些二進制數中，最前面一個位元是 0 的是正數和零，最前面一個位元是 1 的會被解釋成負數，解釋的方法是 2 的補數的方法，可以自行上網了解何謂 2 的補數。簡單來看就是，1111 1111 1111 1111 = 0xFFFF = -1，1111 1111 1111 1110 = 0xFFFE = -2，...。 |
| 最後二行          | 結束程式執行的指令即可                                                                                                                                                                                                                                                                               |

 解釋完組合語言指令後，再來看看其它程式行中的文字所表示的意義，這些文字並不是真正組合語言的指令，只是用來告知組譯器該做何動作的命令，稱為**虛指令**：

| 虛指令                | 說明                                                                                                                                                                                                                                                                      |
| ------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| export _main       | 每個程式都要有程式進入點，連結器在產生執行檔時，會在執行檔中指名該進入點，作業系統載入程式到記憶體中後，會將 ip (instruction pointer，參先前面說明)暫存器的值設成該進入點的位址，細節要等到使用 gas 時再看。目前只要知道這行虛指是讓 ld86 知道 _main 是程式起始點就好，加上我們實際上修改了 ld86 的程式，它只會產生 DOS 的 COM 執行檔，這種執行檔中沒有任何可重定位的資訊，完全只有機器碼，故永遠是第一個組合指令(機器碼)即是進入點，加入這行只是因為沒有的話 ld86 會報錯。 |
| .text, .data, .bss | 指出指令或資料要放的分段，目前都沒有任作用，因為 DOS 的 COM 執行檔只有一個段，指令加上資料最多 64KB。.text 是程式段，一般用來放組合指令碼，.data 段是放資料，在其中的資料會是已初始化的值，例如 C 語言中的宣告 int a=2; ，在這 C 程式中，a 就是有初始化的資料(變數名是 a)，.bss 是放未初始化值的資料分段，例如 C 語言宣告的 int b; 在這 C 程式中，b 就未初始化的資料。                                                  |
| _main:             | **行號(label)**，這裡要給出 _main 行號是因為前面 export 這句虛指令一定要有，故程式開始處必須給它一個行號標記。行號還有其它的用處，主要搭配後面會教到的流程改變指令，程式的基本流程是由上到下，一個指令一個指令由 CPU 取得執行，使用流程改變指令，就可以不受依序由上到下的流程，行號就是用來指出流程到改到的位置。                                                                                                |

#### 用 debug 查看 mov_ex1.com

看完對指令的講解後，要實際看看程式執行的過程，否則沒法在心裡產生具體的印象，這個程式如果在 DOS 中直接執行，什麼效果都看不到，只是改變了 CPU 暫存器的值，程式就結束了，要看清每個指令的作用，要用除錯器一個指令一個指令的執行，才會清楚。

DOS 中的除錯器是 debug，用它來看 COM 執行檔最簡單了，用下列命令啟動 debug 除錯 mov_ex1.com：

    debug mov_ex1.com

進入 debug 程式後，命令等待字元會從 DOS 的 > 變成 _ 底線字元，表示等候你下達 debug 指令，debug 指令不用多學，只要學下面幾個就好：

1. **r 指令**：查看所有暫存器目前的值。

2. **u 指令**：查看目前 IP 暫存器所指位址開始的組合語言指令及機器碼(反組譯)。

3. **t 指令**：執行目前 IP 暫存器所指位址的機器碼，執行完一個指令會暫停等候下個 debug 命令，稱為單步執行。

4. **d 指令**：查看記憶體中的碼(十六進制)，例如 d a000:0000 是查看分段 0xa000 位址 0x000 中的資料。

5. **g 指令**：不論執行到何處，此指令會開始往下不停止的執行完程式。

6. **q 指令**：離開 debug 程式。

![](./Images/2024-08-04-09-10-00-image.png)

以本例而言，第一個機器碼是 B83200 ，對應的組合語言指令是 MOV AX,0032 ，在 debug 中都是使用十六進制值，這個自己要習慣，要注意的是 0032 在記憶體中是 32 在前 00 在後，前面解釋過。上圖中，執行了第一個機器碼後，可看到 AX 暫存器的值變成了 0032 ，也就是我們寫的第一個組合語言指令所欲達到的結果。你可以試著按四次 t 查看暫存器值的變化，然後按 g ，再按 q 回到 DOS 命令提示字元。

> **as86 及 ld86 的 bug**：
> 
> 上述範例中的組合語言指令，如果把數值改成 10，組譯的結果將會出錯，例如把第一個指令改為：
> 
>     mov    ax, #10
> 
> 組譯出的機器碼應該是 B80A00 ，但 as86 會組譯出 B80D0A00 ，而列表檔內容卻是對的，這個錯誤是因為 as86 使用了 open 及 write 函式輸出結果的原因，因為 DOS 的換行是 0x0d0a (可惡的微軟，硬和別人不同)，而 UNIX 的換行是 0x0a ，在用上列函式輸出一個 0x0a 字元到檔案時，都會被自動轉成 0x0d0a。同理觀察 ld86 的輸出結果及程式同樣有這個問題。
> 
> 要證明這點，只要寫一段 C 程式(存檔成 test.c)，如下：
> 
>     #include <sys/types.h>
>     #include <fcntl.h>
>     #include <unistd.h>
>     #include <stdio.h>
>     #define NTOWRITE 3
>     int objfil;
>     char objbuf[NTOWRITE];
>     char* objfilename = "temp.obj";
>     
>     int main()
>     {
>        objbuf[0] = 0xb8;
>        objbuf[1] = 0x0a;
>        objbuf[2] = 0x00;
>        objfil = creat(objfilename, 0666);
>        if (write(objfil, objbuf, NTOWRITE) == NTOWRITE) {
>             printf("write %d bytes to %s\n", NTOWRITE, objfilename);
>        } else {
>             printf("error : write data to %s\n", objfilename);
>        }
>        return 0;
>     }
> 
> 然後用 gcc -o test.exe test.c 編譯成執行檔，而後用下列命令執行 test.exe ，此程式很簡單，只是開啟一個 temp.obj 檔，而後用 as86 類似的函式，將 3 個位元組寫入到該檔案中，執行 test.exe 後，我們可以用 DIR 命令去看檔案資訊，如下圖所示，temp.obj 檔有 4 個元組：
> 
>     c:\tmp\test> test.exe
> 
> ![](./Images/2024-08-05-14-38-51-image.png)
> 
> 再用 hexdump 程式去看 temp.obj 的內容，將看到變成了 B8 0D 0A 00，所以在 DOS 中寫 C 語言程式，用到 write 函式要小心，建議改用 fopen 及 fwrite 寫出 binary 檔案。
> 
> ![](./Images/2024-08-05-14-45-31-image.png)
> 
> 就此看來在 DOS 下使用 DJGPP 的程式都要小心這點，那麼 as86 遇到數值 10 的時候要怎麼辦? 
> 
> 1. 試著修改 as86 及 ld86 程式：我不選這個辦法，不是做不到，而是沒必要了，也許新版的 as86 及  ld86 已修改了這個問題，但本書只是介紹組合語言的寫法，這種舊的組譯程式目前應該也沒人在用了，我們自己知道有這個問題就好了。
> 
> 2. 遇到數值或機器碼是 10 的時候，就不要用，改迂迴的做法，例如把數值 10 拆成 5+5，不用含 10 的機器碼，可能有點麻煩，但對寫程式來說也沒問題。
>    
>    例如：
>    
>        mov    ax, #10
>    
>    改成 
>    
>        mov ax, #5
>        add ax, #5

## 第5章 記憶體分段及指令定址模式

#### 8086 分段及 DOS 記憶體使用情形

前面的例子中，用 debug 把 mov_ex1.com 載入到記憶體中時，可以看到 CS, DS, ES, SS 分段暫存器的值都是 0x06F2，表示程式、資料、堆疊都使用同一個段，有關堆疊(stack)後面會再詳述，目前關心的是，整個電腦的記憶體是如何使用的?

首先將前面一直沒有介紹的分段(segmentation)技術交代清楚，8086 CPU 雖然是十六位元 CPU ，資料匯流排大小是 16 條線，原本位址線也可以簡單地只設計成 16 條線，這樣總體記憶體大小就限制為 64KB 了，為了能使用更大的記憶體空間，就要有更多的位址線，但是 IP (所有)暫存器只有 16 位元大小，也就是程式若依 IP 的位址去執行最多也只能是 0x0000 ~ 0xFFFF ，所以 Intel 工程師加了 CS 分段暫存器，CS 同樣是 16 位元暫存器，但 CS 和 IP 二個暫存器合起來看就可以不止 16 位元了。

如下圖(取至 8086 datasheet)所示，分段暫存器會指向記憶體中的某個位置，例如 CS 指向 0x06F2 分段位置，而後 IP 可以指向該位置後的 64KB 的某一記憶體位址，這個 CS 所指的分段就是下圖中的 CODE SEGMENT。

那麼這個 CS 所指的分段位置究竟在總體記憶體的什麼位置呢?下圖 CODE SEGMENT 下面有一個 XXXX0H 的字樣，那個 XXXX 就是代表要把 CS 的值填入的意思，故 CS 值若是 0x06F2，則表示它所指的真正位址是 0x06F20 這個記憶體位址。

依上例第一個組合語言指令位置是 06F2:0100，06F2 是分段的位置，0100 是分段中指標所指的位址，我們叫它做**偏移值(OFFSET)**，結合 SEGMENT:OFFSET 得到的值即是 0x06f20 + 0x0100 = 0x07020 ，這就是第一個組合語言指令在真實記憶體的位址，換算成二進制是 0000 0111 0000 0010 0000 總共 20 個 0,1 ，也就是 8086 實際上對外共有 20 條位址線，AD0 - AD15 加上 A16 - A19 條線的原因。

![](./Images/2024-08-04-13-53-01-image.png)  

經過上面的解說，很多人會聽得模模糊糊或者有些疑問，為何怎樣奇怪的設計?不是只要把 CS 和 IP 結合成一個 32 位元(16+16)的位址就好了，為何變成 20 位元的位址，而且計算真實位址的方式還真是奇怪。只能說若做成 32 位元位址線，在當時非常不切實際，那時 640KB 記憶體已非常昂貴，記得幾年後 1MB 至少 1000 元台幣，若是 32 條位址線插滿則有 4GB 記憶體是 1MB 的 400 倍，要 40 萬台幣，總之，當時(198x年代)只須要大約 20 條位址線就可滿足幾乎所有需求，即使到了 1995 年的 Windows 95 年代，記憶體超過 480MB 好像就會出問題了，這個數字也是後來微軟說的，當時建議的記憶體大小是 8MB。32條位址線要到下一個十年才算普及，至今有很多電腦也是才 4GB 記憶體而已。

這個 20 位元記憶體位址的算法也造成了有趣的現象，例如 0x06F2:0x0100 的真實位址是 0x07020，和 0x0702:0x0000 的真實位址是一樣的，如下圖所示，二個分段位移的組合所得到的資料是一樣的。 

![](./Images/2024-08-04-14-13-41-image.png)

理解了 8086 分段位址的算法後，下圖說明了 8086 CPU 硬體自身會用到的記憶體部份，這些部份要保留給硬體使用，作業系統及應用程式都不可以去使用到它們，否則 CPU 可能會失效，即我們說的程式亂掉，系統當機。

第一個保留區段是記憶體位址 0xFFFF0 ~ 0xFFFFF 共 16 個位元組， 8086 CPU 在通電重置後會跳到 0xFFFF0 記憶體位址拿取第一個指令來執行，所以這裡一定要有指令可以讓 CPU 可以取得，一般會放一個 ROM 記憶體去涵蓋這個區域，因為 ROM 就算沒電裡面資料永遠都在，每次開機拿到的資料也永遠一致。至於這個 ROM 要多大，則是由電腦製造商決定，當時這裡是放了一個 8KB 的  ROM，裡面是 BIOS (Basic Input Output System)程式，開機後會執行裡面的程式，跑些系統設定及測試，然後載入軟碟或硬碟中的作業系統。

第二個保留區段是 0x00000 ~ 0x003FF，是中斷向量表，這在後面講中斷時會詳細說明，重要的是我們的程式不可以隨意地去動它，但人是奇怪的動物，愈是叫我不要動，我就愈想去動看看。

![](./Images/2024-08-04-14-38-52-image.png)

除了上圖中的二個區域，我們的組合語言程式不要去亂動外，還有 DOS 作業系統程式所佔用的記憶體，我們也不要去亂動它，這些記憶體區段是 ROM BIOS 從磁碟中載入 DOS 到記憶體中，並且經過 DOS 程式初始化後所佔用的區域。

![](./Images/2024-08-05-15-28-09-image.png)

上圖是 BIOS 載入 DOS 後大致的記憶體分佈圖， DOS 有許多的版本，每個版本所佔記憶體大小不同，目前網上有公布了 DOS 1.25、DOS 2.0 及 DOS 4.0 的原始程式，從最早的 DOS 版本開始，和上圖就差不了多少，公布的 DOS 1.25 中的 IO.ASM 組譯後的二進制檔會放在磁碟檔案系統中的第一個檔案，一般而言，是 FAT 格式的檔案系統，BIOS 會載入磁碟第一個磁區的程式，DOS 4.0 原始碼的 BOOT/MSBOOT.ASM 經過組譯後就是這第一個磁區的資料。

    ;
    ; We load in the first directory sector and examine it to make sure the the
    ; BIOS and DOS are the first two directory entries.  If they are not found,
    ; the user is prompted to insert a new disk.  The directory sector is loaded
    ; into 00500h
    ;
        MOV    BX,DirOff       ; sector to go in at 00500h
        mov    dx,[DIR$_H]     ;AN000;
        MOV    AX,[DIR$_L]     ; logical sector of directory
        CALL    DODIV          ; convert to sector, track, head
        jc    CKErr            ;AN000; Overflow? BPB must be wrong!!
    ;     MOV     AX,0201H     ; disk read 1 sector
        mov    al, 1           ;AN000; disk read 1 sector
        CALL    DOCALL         ; do the disk read
        JB    CKERR            ; if errors try to recover
    ;
    ; Now we scan for the presence of IBMBIO  COM and IBMDOS  COM.    Check the
    ; first directory entry.
    ;
        MOV    DI,BX
        MOV    CX,11
        MOV    SI,OFFSET BIO   ; point to "ibmbio  com"
        REPZ    CMPSB          ; see if the same
        JNZ    CKERR           ; if not there advise the user
    ;
    ; Found the BIOS.  Check the second directory entry.
    ;

以上程式是從 DOS 4.0 MSBOOT.ASM 摘錄出來，你可以查看程式並比對註解中的說明，了解此程式會先比對頭二個檔案是不是 IO.SYS 和 MSDOS.SYS (程式中是 IBMBIO.COM 及 IBMDOS.COM)，然後再繼續載入它們，最後把執行權交給它們，DOS 作業系統做完它自己的事後，就載入 COMMAND.COM ，這個程式類似 UNIX 的 shell 程式，顯示提示字元，等候使用者輸入命令，根據命令去執行指定的任務，其中之一就是載入你的組合語言程式來執行。

由於各版 DOS 這些檔案大小都不一樣，所以最終你的程式被載入的位址都會不同，所以上圖中應用程式區的開頭位址才會沒有畫出來，總之，當你的程式被載入到記憶體中後，例如之前 mov_ex1.com 載入後位址是 0x07020 ，你可以想成由這個位址一直到 0xA0000 之前的記憶體位址都可以由你使用，因為 DOS 一次只能執行一個程式(multitask DOS 除外)，在你程式結束前，整個應用程式區域都是你的組合語言程式可以使用的位址。

事實上，DOS 作業系統沒有任何防護的功能，你要亂用整個電腦的所有記憶體也沒人能管你，這就是當時有些程式動不動就當機，然後只能重置(reset)電腦的原因了。對此，我的看法是好壞各半，不予評論，以當時硬體沒有提供保護機制的情形下，做任何保護都是白做工。而且我的電腦我自己負責，憑什麼要把 CPU 時間分出去給你防毒軟體或作業系統的爛服務使用，現在的作業系統都是安全的(2024/07/19又浮現我腦海)，但並非所有電腦資源供我驅策，試想若有一個 64 位元的 DOS 系統給你使用，同一時間只有一個程式在執行，例如遊戲或編譯器IDE，會不會比較快?可想而知，應該會比較不安全。

#### 8086 定址模式

前面一個範例中，若把 # 拿掉會變成什麼意思呢?亦即把

        mov    ax, #50

改變成

        mov    ax, 50

後者的意思和原本是不一樣的了，後者的 50 是記憶體位址 50 的意思，而不是數值 50 的意思，所以整個指令的意義是「從記憶體位址 50 的地方拿取資料，而後放到 ax 暫存器中」。這邊順便指明一個東西，記憶體位址 50 的資料放到 ax 中後，該位址中是什麼?答案是，不變，記憶體中資料拿出後，裡面的資料不會不見或變成虛無。

像上面這種資料來源的寫法不同，拿取資料的地方就會不同的指定格式，就叫做「定址模式」。8086 的定址模式有很多種，在此先大致分成下列幾種，先把這幾種基本定址模式弄清楚，其它的就觸類旁通了。

| 定址模式        | 說明                                                                                                                                                                                                   |
| ----------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **暫存器定址**   | 指令的來源及目的地都是暫存器，例如 mov bx, ax 是把 ax 暫存器的值放到 bx 暫存器中。                                                                                                                                                  |
| **暫存器間接定址** | 指令的來源或目的地是記憶體，而該記憶體位址是在暫存器中，例如 mov ax, [bx] 是把 bx 暫存器中的值當做記憶體位址，而後由該位址提取資料放到 ax 暫存器中。一般可用做暫存器間接定址的暫存器是 bx, di, si。                                                                                   |
| **立即定址**    | 指令的來源部份就是要運算的數值，例如 mov ax, #50，#50 就是一個資料。                                                                                                                                                           |
| **絕對定址**    | 指令的來源或目的地部份是記憶體的位址，該位址的資料就是要運算的資料，例如 mov ax, 50 的運算資料是放在記憶體 50 的地方。mov 0x400, ax 是要把 ax 暫存器的值放到記憶體位址 0x400 去。                                                                                        |
| **索引定址**    | 指令的來源或目的地是記憶體，但該記憶體位址是結合絕對記憶體位址加上一個暫存器(索引)的值而得到，例如 mov ax, 0x400[bx]，是把絶對記憶體位址 0x400 加上 bx 暫存器的數值所形成的位址，到該位址處去取得資料放到 ax 暫存器中。這種用法很像 C 語言中的位元組陣列用法，把 0x400 看成是位元組陣列所在的位址， bx 是要存取陣列中第幾個元素的索引值(index)。 |

示範程式如下(請自行存檔為 mov_ex2.s，並按前述過程組譯連結)，詳細各指令的說明請參考上面各定址法的說明去理解：

    export _main
    .text
    _main:
            mov     ax, #0x300    ; 把數值 0x300 放到 ax 中
            mov     0x400, ax     ; 把 ax 數值放到記憶體位址 0x400 去
            mov     ax, #0x500
            mov     0x300, ax
            mov     ax, 0x400     ; 把記憶體位址 0x400 的內容取出放到 ax 中
            mov     bx, ax        ; 把 ax 暫存器的值放到 bx 中
            mov     cx, [bx]      ; 把 bx 的值當成記憶體位址, 將該位址的內容放到 cx
            mov     dx, [0x400]   ; 等於 mov dx, 0x400
            mov     ah, #0x4c
            int     0x21
    .data
    .bss

組譯連結後，用 debug 單步執行結果如下，可以看到最終 CX 暫存器的值是 0x0500，DX 暫存器的值是 0x0300。

![](./Images/2024-08-06-07-56-25-image.png)

上面範例沒有包含索引定址的範例，以下列範例說明之，請自行組譯連結並用 debug 查看執行過程：

    export _main
    .text
    _main:
        mov     ax, #0x300    ; 把 0x300 數值放到 ax 暫存器中
        mov     0x420, ax     ; 把 ax 暫存器的值放到記憶體位址 0x420 處
        mov     bx, #0x20     ; 把 0x20 數值放到 bx 暫存器中
        mov     cx, 0x400[bx] ; 把 0x400+bx 的值當做位址, 至該位址取出資料放到 cx 中
        mov     ah, #0x4c
        int     0x21
    .data
    .bss

> **ld86 bug:**
> 
> 我們使用的 ld86 除了前面說過會將 0x0a 資料變成 0x0d0a 外，還有一個奇怪的 bug 在，例如下列程式可以正常組譯連結：
> 
>     export _main
>     .text
>     _main:
>             mov     ax, #0x300
>             mov     0x400, ax
>             mov     ax, #0x500
>             mov     0x300, ax
>             mov     bx, 0x400
>             mov     bx, 0x400
>             mov     cx, [bx]
>             mov     dx, [0x400]
>             mov     ah, #0x4c
>             int     0x21   
>     .data
>     .bss
> 
> 但下列程式在連結時就會出現錯誤訊息，c:/djgpp/bin/ld86.exe: premature end of input file test.o，前後只差一行，我還試了刪減別行程式，有時又可以連結成功，由於實在看不出具體規律，所以只能在此提示讀者，不用花時間去查它為何出錯或嘗試修正 ld86 程式，最多是去下載 bin86 的新版回來使用看看，未來本書示範程式都是可用我們手上的 as86 及 ld86 組譯連結成功：
> 
>     export _main
>     .text
>     _main:
>             mov     ax, #0x300
>             mov     0x400, ax
>             mov     ax, #0x500
>             mov     0x300, ax
>             mov     bx, 0x400
>             mov     cx, [bx]
>             mov     dx, [0x400]
>             mov     ah, #0x4c
>             int     0x21   
>     .data
>     .bss

#### 程式段前置區域 PSP(Program Segment Prefix)

前面在說明範例程式時，提到位址時，都只有 16 位元位址，例如 0x0400 是指 CS 分段中的位址，原因是我們目前所寫的程式在載入記憶體中時，只會佔據一個分段，CS, DS, ES, SS 四個段暫存器的值都一樣，程式的指令操作的記憶體都是在載入時的分段中進行，所以就都只提到 16 位元的位址，事實上，8086 組合語言指令可以指定分段位址，以操作不是載入分段的記憶體，目前若無別聲明，提到記憶體位址時仍是指載入時的那個分段中的位址。

另外在前面用 debug 載入程式來查看指令的執行時，你應該會發現第一個機器碼的位址是在 0x0100，這個起始位址很重要，後面的例子中會用到這個位址。那麼在這個位址前是什麼東西呢?答案是 DOS 系統中用來儲存程式狀態的資料結構，叫做**程式段前置區域**（**PSP**），如下圖所示。

![](./Images/2024-08-06-09-59-15-image.png)

上表 0x00 - 0x01 二個位元組中是 0xcd 0x20 機器碼，換成組合語言指令是 int 0x20 ，執行這行指令就會結束程式的執行，在這個位址放結束程式的機器碼說是相容 CP/M-80 作業系統，可是原因是為何呢?雖然和本書無關，但因為有趣所以提一下，以往的電腦容量非常小，只有幾 KB 而已，程式載入到記憶體中後能不能放得下，也搞不清楚，就算放進去了執行結果也很難預料，假設 IP 不知道為何已經執行到實體記憶體的最後一個位元組，再往下就又會從位址 0x00 處拿到機器碼，這時其實已出問題了，但因為在記憶體 0x00 處拿到的機器碼是結束程式的執行，所以程式就可以莫明奇妙的結束了。

(程式莫明奇妙的結束了，總比作業系統莫明奇妙當掉了要好，誰想到這麼妙的點子，請大家一同向 CP/M-80 的發明者致敬)

FCB 是什麼請自行查看維基百科中的說明，網址是 https://en.wikipedia.org/wiki/File_Control_Block

在 FCB 結構中可以查到程式的磁碟編號，主要早期 DOS 程式使用。

PSP 最常用於取得DOS 程式的命令列引數，由 0x0d 結束，例如，指令 "as86 -0 -o test.o test.s" 使用引數 "-0" 和 "-o test.o" 傳入 as86 ，我們自己寫的程式也可以接受命令列引數，在 PSP 中的命令列引數大小限制在 127 位元組，通常是不會超過，如果有超過 DOS 還有系統服務可以取得完整的命令列引數。

PSP 中有很大一段的資料對我們現今學習 8086 組合語言程式，已完全不重要，畢竟連使用到 8086 組合語言的場合也已幾乎不存在了，但是先學會了簡單的 8086 組合語言指令，後續再學 80386 組合語言，將更容易些。

讓我們用 debug 載入前面的 mov_ex2.com 程式，然後查看 0x0000 - 0x00FF 記憶體的內容，如下圖所示：

![](./Images/2024-08-06-14-30-23-image.png)

由於是用 debug 載入 mov_ex2.com 來執行，故對 debug 來說 mov_ex2.com -s -o 是它的命令列引數，而 -s -o 則是 mov_ex2.com 的引數，所以才會出現如上圖，有點奇怪的結果，將來等學完所有 8086 組合語言指令碼後，你就可以自己寫程式來從 PSP 中取得命令列引數了。

## 第6章 軟體中斷

#### 軟體中斷介紹

組合語言程式翻譯成機器碼後，是由 CPU 從記憶體中依序由上至下取出機器碼來執行，不會轉彎，但是在我們的程式執時，其它的電腦周邊硬體並不會停止不動，例如時鐘或磁碟，在我們程式執行過程中，若硬體有事要處理，一定要有別的程式能去處理它們，這個機制就是中斷，周邊硬體利用一個 INT 的電線信號連到 CPU (8086 block diagram 右側)，CPU 收到這個信號就知道有周邊要中斷我們的程式，CPU 要去跑別的程式來從周邊拿資料或送資料到周邊，硬體細節不再多說明，我們只要知道我們的程式會被中斷去執行別的程式，這稱為**硬體中斷(hardware interrupt)**。

前面講的中斷程式不是我們寫的程式(目前)，所以只能是 ROM 或 DOS 的程式了，它們會去處理這些硬體的細節，不用我們操心。除了硬體中斷外，ROM 和 DOS 都會提供軟體中斷以供我們自己中斷我們的程式，跑去 ROM 或 DOS 中執行它們提供的功能，等跑完這個功能後就會回到我們的程式中，這就是**軟體中斷(software interrupt)**，又可稱為作業系統的系統呼叫(system call)或系統服務(system service)。

ROM 中的 BIOS 程式同樣也會提供軟體中斷，我們只要知道中斷的號碼及使用的方式，就可以利用 ROM BIOS 的提供的服務了。由於前面的範例都沒有輸出結果到顯示幕上，要用 debug 程式去看結果，所以我要先學會如何將資料送到顯示器上去顯示。

每個程式最後的 

        mov ax, #0x4c00    ; ah = 0x4c, al = 0x00
        int 0x21

也是軟體中斷，只是它是 DOS 提供的軟體中斷服務， 0x4c 表示程式結束的意思，放在 ah 暫存器中，al 暫存器中則是結束的傳回值，傳回 0x00 一般表示程式正常結束沒有出錯，非 0x00 的數值則要看該程式的定義。

#### ROM BIOS 軟體中斷 ─ int 0x10

int 0x10 是和顯示器(顯示卡)有關的中斷，在維基百科中有詳細的中文說明，如下列網址：

https://zh.wikipedia.org/wiki/INT_10H

我們較關心的是 int 0x10 中的幾個服務，列出說明如下：

| AH   | 其它輸入值                                                          | 返回值                                       | 功能說明      |
| ---- | -------------------------------------------------------------- | ----------------------------------------- | --------- |
| 0x03 | BX=頁碼                                                          | CH=游標掃描開始行，CL=游標掃描結束行，DH=游標的行位置，DL=游標的列位置 | 取得游標位置和形狀 |
| 0x0a | CX=列印次數，BH=頁碼，AL=輸出字元ASCII碼                                    | 無                                         | 輸出字元      |
| 0x13 | AL=寫出模式，BH=頁碼，BL=顏色，CX=字串長度，DH=游標的行位置，DL=游標的列位置，ES:BP=字串分段:偏移值 | 無                                         | 輸出字串      |

> 上面有二項要補充說明：
> 
> 1. **頁碼**：
> 
> 2. **顏色**：

利用上面說明的 ROM BIOS 服務，我們可以寫出下列示範程式(int10.s)：

    export _main
    .text
    _main:
            jmp start             ; 跳到 start 處去執行
    msg:
            .ascii "Hello world!"
    start:
            mov     ah, #0x03     ; ah = 0x03
            mov     bx, #0
            int     0x10          ; int 0x10 取得游標位置
            mov     cx, #12       ; 印出字串長度
            mov     ax, #msg      ; 印出字串的位址
            add     ax, #0x100    ; 加上 PSP 的長度
            mov     bp, ax        ; 真正 msg 位址放到 bp 中
            mov     bh, #0x00     ; 頁碼
            mov     bl, #0x0f     ; 顏色
            mov     ah, #0x13     ; ah = 0x13
            mov     al, #0x01     ; 模式
            int     0x10          ; int 0x10 輸出字串
            mov     ax, #0x4c00
            int     0x21
    .data
    .bss

執行結果如下圖所示：

![](./Images/2024-08-07-13-31-41-image.png)

整個程式很容易理解，取得游標位置後，在該游標位置輸出 Hello world! 字串。唯有以下幾點要再說明：

1. 程式碼只有一個段，所以把要輸出的字串放在程式分段中。在第一個組合語言指令後就定義資料，第一個指令是沒看過的指令，jmp 是 jump 的縮寫，中文是跳走的意思，jmp 後接著一個行號，表示 CPU 執行這個指令後，會把該行號的位址放到 ip 暫存器，而不是依序遞增，效果就是跳到該行號去執行下一個指令。

2. msg 也是行號，在這個位址處不是放組合語言指令，而是放了一段 ACSII 字元的字串在這裡，組譯器會把每個字元的 ASCII 碼直接組譯到執行檔中，像這樣的位址處存放的就不是指令，而是資料。一般資料會放在資料分段，而資料分段和程式分段可以不是同一分段，目前的 COM 執行檔只能有一個分段，要看到有不同分段的執行檔，要等到後面講解 EXE 執行檔時才會看到。

3. add ax, #0x100 指令是把 0x100 的數值加到 ax 暫存器中，在此之前 ax 暫存器的值是 msg 的位址，由於 ld86 把整個程式當成一個段看待，在產生 int10.com 執行檔時，第一個機器碼就是放在 0x0000 位址，而後遞增位址計數，直到把整個程式都寫出到執行檔中為止，然而在 DOS 載入 int10.com 程式時，會在前 0x00 - 0xFF 放 PSP 資料，第一個機器碼會載入到 0x0100 的記憶體位址，這樣磁碟中的位址和記憶體中的位址會相差 0x100 個位元組，所以要把 msg 的位址多加 0x100 加以修正。

#### ROM BIOS 軟體中斷 ─ int 0x16

前面介紹了輸出到顯示器的方法，接著要介紹如何從鍵盤讀取輸入的資料。BIOS int 0x16 的軟體中斷是用來從鍵盤讀取按鍵的服務，在維基百科中對 int 0x16 有詳細的說明，如下網址：

https://en.wikipedia.org/wiki/INT_16H

在此我們只關心其中我們會用到的功能：

| AH   | 其它輸入值 | 返回值                      | 功能說明 |
| ---- | ----- | ------------------------ | ---- |
| 0x10 | 無     | AL=按鍵的ASCII碼，AH=按鍵的scan碼 | 讀取按鍵 |

每個鍵盤上可見的字母或數字都有一個相對應的 ASCII 碼，但有些鍵並沒有可見的符號，例如 F3、enter 鍵，這些特殊按鍵可以用 scan 碼加以分別，在此先了解 ASCII 碼即可。下表(取至維基百科)列出了可見字元相對應的 ASCII 碼，例如數字 '0' 這個字元，對應的 ASCII 碼是 0x30，'1' 是 0x31 ，依此類推。

![](./Images/2024-08-07-16-07-30-image.png)

示範程式如下，此程式先印出 Please press a key 的提示訊息，然後利用 int 0x16 等候使用者輸入按鍵，然後將使用者輸入的按鍵印出 3 次：

    export _main
    .text
    _main:
            jmp start             ; 跳到 start 處去執行
    msg:    .ascii "Please press a key : "
    start:
            mov     ah, #0x03     ; ah = 0x03
            mov     bx, #0
            int     0x10          ; int 0x10 取得游標位置
            mov     cx, #21       ; 印出字串長度
            mov     ax, #msg      ; 印出字串的位址
            add     ax, #0x100    ; 加上 PSP 的長度
            mov     bp, ax        ; 真正 msg 位址放到 bp 中
            mov     bh, #0x00     ; 頁碼
            mov     bl, #0x0f     ; 顏色
            mov     ah, #0x13     ; ah = 0x13
            mov     al, #0x01     ; 模式
            int     0x10          ; int 0x10 輸出字串
            mov     ah, #0x10     ; ah = 0x10 
            int     0x16          ; int 0x16 讀取按鍵
            mov     cx, #3        ; 重覆 3 次
            mov     bh, #0        ; 頁碼
            mov     ah, #5        ; ah = 0x05
            add     ah, #5        ; ah = 0x0a, al = 字元
            int     0x10          ; int 0x10 輸出一個字元
            mov     ax, #0x4c00
            int     0x21
    .data
    .bss

> 本程式有一個奇怪的地方，就是我們把 mov ah, #0x0a 拆開成 mov ah, #5 和 add ah, #5 二個組合語言指令，這是因為 as86 和 ld86 遇到寫出 0x0a 到檔案時，會把它改為 0x0d0a ，請參考前面 as86 bug 的說明

將上述程式存檔為 int16.s ，組譯連結後，執行結果如下圖：

![](./Images/2024-08-10-06-43-43-image.png)

#### DOS 軟體中斷 ─ int 0x21

前面介紹的軟體中斷是在 ROM 中的 BIOS 程式所提供，有基本硬體的輸出入支援功能，在沒有作業系統的情形下，只能使用這些軟體中斷所提供的服務，在載入 DOS 作業系統後，DOS 也會提供軟體中斷給應用程式使用，使用 DOS 軟體中斷的方法和上面一樣，把要使用的功能代碼放在 AH 暫存器中，然後用 int 0x21 即可呼叫 DOS 的服務。

| AH   | 其它輸入值         | 返回值                            | 功能說明                                    |
| ---- | ------------- | ------------------------------ | --------------------------------------- |
| 0x01 | 無             | AL=按鍵的 ASCII 碼                 | 讀取使用者輸入，會暫停程式的執行，直到使用者按下按鍵為止。           |
| 0x06 | DL=0xff       | ZF=1，AL是 ASCII 碼。ZF=0，則表示沒有按鍵。 | 讀取使用者輸入，不會暫停程式的執行，若有讀取到按鍵，則設定 ZF 旗號為 1。 |
| 0x06 | DL=輸出字元       | 無                              | 在標準輸出上輸出一個字元                            |
| 0x09 | DS:DX=字串位址    | 無                              | 在標準輸出上輸出一串字串                            |
| 0x0A | DS:DX=緩衝區結構位址 | 輸入字串在緩衝區結構中                    | 從標準輸入讀取字串放在緩衝區結構中                       |
| 0x2A | 無             | CX=年，DH=月，DL=日，AL=星期幾          | 取得當前的日期                                 |
| 0x2C | 無             | CH=時，CL=分，DH=秒，DL=百分之一秒(不準)    | 取得當前時間                                  |

int 0x21 0x0A 功能中的緩衝區結構內容如下：

    keybuffer:
        db 80        ; 輸入緩衝區最多可容納的位元組數
        db 0         ; 字串輸入後，存放輸入字元個數的位置
        .space 80    ; 輸入字串存放的緩衝區(80個位元組)

## 第7章 組合語言指令 ─ 基本算術指令

    export _main
    .text
    _main:
            jmp _readA
    _msg1:  .ascii "Please input A : "
    _msg2:  .ascii "Please input B : "
    _msg3:  .ascii "A+B="
    _readA:
            mov     ah, #0x03
            mov     bx, #0
            int     0x10
            mov     cx, #_msg2 - _msg1
            mov     ax, #_msg1
            add     ax, #0x100
            mov     bp, ax
            mov     bx, #0x000f
            mov     ax, #0x1301
            int     0x10
            mov     ah, #0x10
            int     0x16
            mov     cx, #1
            mov     bh, #0
            mov     ah, #5
            add     ah, #5
            int     0x10
            sub     al, #0x30
            mov     0x400, al
    _readB:
            mov     ah, #0x03
            mov     bx, #0
            int     0x10
            inc     dh
            mov     dl, #0
            mov     cx, #_msg3 - _msg2
            mov     ax, #_msg2
            add     ax, #0x100
            mov     bp, ax
            mov     bx, #0x000f
            mov     ax, #0x1301
            int     0x10
            mov     ah, #0x10
            int     0x16
            mov     cx, #1
            mov     bh, #0
            mov     ah, #5
            add     ah, #5
            int     0x10
            sub     al, #0x30
            add     al, 0x400
            mov     0x400, ax
            mov     ah, #0x03
            mov     bx, #0
            int     0x10
            inc     dh
            mov     dl, #0
            mov     cx, #_readA - _msg3
            mov     ax, #_msg3
            add     ax, #0x100
            mov     bp, ax
            mov     bx, #0x000f
            mov     ax, #0x1301
            int     0x10      
            mov     ax, 0x400
            mov     ah, #0x00
            mov     bh, #11
            dec     bh
            div     bh
            add     al, #0x30
            add     ah, #0x30
            mov     0x400, al
            mov     0x401, ah
            mov     ah, #0x03
            mov     bx, #0
            int     0x10
            inc     dh
            mov     dl, #0
            mov     cx, #2
            mov     ax, #0x400
            mov     bp, ax
            mov     bx, #0x000f
            mov     ax, #0x1301
            int     0x10      
    
    _end:
            mov     ax, #0x4c00
            int     0x21     
    .data
    .bss

## 附錄A 在 Android 中使用 DOSBox

1. 首先到 Goggle 商店中搜尋 Magic DosBox Lite 軟體，並安裝它。此版只能裝一個系統(它原本目的是 DOS 遊戲)，這對我們來說足夠了。

2. 執行該軟體，第一次執行會問你是否允許存取裝置的相片和影片，要不要答允許就看你，答「全部允許」後，會開始進入設定。按一次下一步後，會問你「遊戲檔案夾」位置，請按「選擇」，並設定為 \Documents (文件)位置，其它目錄有些不准，有些看不到。 例如下圖，請在下方「使用這個資料夾」按一下：

![](./Images/2024-07-22-08-12-37-image.png)

3. 接著它會變成下圖，請按「允許」，這樣以後 DOSBox 的 C:\ 磁碟就是這個目錄了。

![](./Images/2024-07-22-08-15-11-image.png)

4. 接著又會要選一個目錄來存設定，請按上述方式，也選擇在 Documents 目錄，等進到程式後，在左手邊有一個 + 的圖示，按下它來新增一個 DOS 系統。

5. 請在如下圖視窗中，上方標題打「DOS」 ，中間記憶體設成 「64MB」，Cpu 設成 「normal」，性能調成「週期：最大」，往下捲動可以看到一個主程式的選擇，這要等把整個 DOS4 系統從電腦搬到平板時，才在此設成 autoexec.bat ，目前可以先空白，直接在卜方打勾處按下去，如下圖：

![](./Images/2024-07-22-08-33-01-image.png)

6. 產生一個系統後，可以把 Windows 中的 DOS 目錄整個壓縮，然後傳到手機或平板的 Documents 目錄中，再解壓縮，就全部都安裝好可以用了。

7. 若要再次設定系統，可以在 dos 圖示上面按久一點，跳出選單後，按「編輯」即可。

8. 在 dos 圖示上點一下就可以執行 DOSBox 了。

9. 出現 DOS 後，只要按 Android 的倒回鍵，就可以叫出螢幕鍵盤來寫程式了。

## 附錄B DOSBox 中的 Apple II 模擬器

下列網址是一個可以在 DOSBox 中執行的 Apple II 模擬器，不僅有執行檔，還有原始程式，它的原始程式全都是用組合語言寫的，正和本書的內容相關，可以拿來學習研究。

https://github.com/zajo/appler?fbclid=IwAR3zI2GPGLd_JSBnZiqbRpfNM_DkZQlDVcrypvfbiwmcvg9fEZNZkqI6CIc

下載其中的 bin 目錄的所有檔案到 DOSBox 中的 C:\tmp 目錄中，啟動 DOSBox ，以下列指令即可啟動 Appler 模擬器。

    cd c:\tmp
    appler

啟動 appler 模擬器後，視當時裝載的磁碟內容會跑不同的程式，如果什麼都沒有，有時會跑 Apple II 監督程式或 BASIC 直譯器。

> 要查看如何使用 appler ，只要在啟動 appler 後，按下 F10 鍵，即可看到所有的命令，其中較常用的列在此：
> 
> 1. Alt + X 結束 appler
> 
> 2. Alt + F2 載入 Floppy ，似乎是載入 *.ROM 的檔案，載入後按 F1 開始執行
> 
> 3. Alt + F3 載入磁碟，載入 *.DSK 的檔案，載入後按 F1 開始執行

以下用一個範例說明 appler 的大致使用方法，要先去網路上下載 Apple II 的磁碟片，這我想到以前有一個叫綠寶石爭奪戰(Gemstone Warrior)的遊戲，我上網一查，古灰遊戲有可以下載，下載來的檔案用 7-zip 解壓縮(可能要先解 gz ，再解 tar，都是用 7-zip 按右鍵去解)，把其中的檔案改名成 gemstone.dsk ，不要用長檔名，把它拷貝到 C:\Users\usr\Documents\DOS\tmp 中，和 appler 程式放在一起，然後啟動 DOSBox，再用上面命令啟動 appler，等幾秒後按 Alt +F3，執行畫面如下：

![](./Images/2024-07-22-06-17-44-image.png)

用上下鍵，把遊標移到 gemstone.dsk 上，按一下 enter 鍵將其放入 Driver 1 中，然後按 F1  即可開始遊戲。模擬速度視你的電腦而定，畢竟是模擬器中的模擬器，我用是覺得速度還可以。等開頭畫面後，亂按 enter 或 SPACE 鍵，直到下列畫面：

![](./Images/2024-07-22-06-21-31-image.png)

此時可以按 b 鍵，開始簡單模式遊戲，或者 n 鍵開始正常遊戲模式，...

請自己玩看看，操作方式以下圖參考，注意是傳統 Apple II 的鍵盤，和現今鍵盤對應起來也差不多。

![](./Images/2024-07-22-06-25-08-image.png)
